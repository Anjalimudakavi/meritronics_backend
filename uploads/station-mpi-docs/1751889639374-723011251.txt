# # # from django.shortcuts import render, redirect
# # # from django.contrib.auth import authenticate, login, logout
# # # from rest_framework import generics
# # # from django.db.models import Q
# # # from rest_framework.views import APIView
# # # from rest_framework.response import Response
# # # from rest_framework.parsers import MultiPartParser, FormParser
# # # from rest_framework import status
# # # from .models import (
# # #     Excelfile,OrderDetails,Manufacturers,Components,Suppliers,BomDetails,ComponentOrderData,RawData,BomDataRaw,
# # # )
# # # from .serializers import (
# # #     ExcelFileSerializer,BomDetailsSerializer,SupplierSummarySerializer,ManufacturerSerializer, ComponentOrderDataSerializer,SupplierSerializer,RawDataSerializer,BomDataRawSerializer,
# # # )
# # # import warnings
# # # import logging
# # # from django.http import HttpResponse
# # # from collections import defaultdict
# # # from .serializers import ExcelFileSerializer  # Import your serializer
# # # from django.contrib.auth import authenticate, login
# # # from django.contrib.auth import logout
# # # import os
# # # import tempfile
# # # from django.contrib import messages
# # # from .process_excel_file import process_excel_file, parse_excel_file, save_parsed_data
# # # # Optional: suppress future warnings for pandas downcasting
# # # from .forms import UploadFileForm, OrderSearchForm, SignUpForm,ComponentSearchForm
# # # from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
# # # from .service import (
# # #     paginate_queryset, calculate_bom_summary,
# # #     get_bom_data_by_order, get_filtered_orders,search_component_by_part_number,
# # #     search_mouser_component,fetch_from_oem_secrets,fetch_or_cache_component_data,
# # #     fetch_or_cache_component_data, paginate_queryset,calculate_bom_summary,   
# # # )
# # # from .models import PartSearchData
# # # import json
# # # from django.core.exceptions import ValidationError
# # # warnings.simplefilter(action='ignore', category=FutureWarning)
# # # logger = logging.getLogger(__name__)
# # # def home(request):
# # #     return HttpResponse("Welcome to the Excel Upload API. Use /api/upload/ to upload your Excel file.")
# # # class UploadExcelView(APIView):
# # #     parser_classes = [MultiPartParser, FormParser]  # For file parsing support
# # #     def post(self, request, *args, **kwargs):
# # #         # Use the serializer to handle the file upload
# # #         file_serializer = ExcelFileSerializer(data=request.data)
# # #         if file_serializer.is_valid():
# # #             # Save the file instance and retrieve the file path
# # #             file_instance = file_serializer.save()
# # #             excel_file = file_instance.file.path  # Get the file path
# # #             # Now process the file and return the response
# # #             return process_excel_file(excel_file, request, return_json=True)  # Pass the file path to process the file
# # #         # If the serializer is not valid, return the errors
# # #         return Response(file_serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
# # # class BomByOrderIDView(APIView):
# # #     def get(self, request, order_id):
# # #         try:
# # #             order = OrderDetails.objects.get(order_id=order_id)
# # #         except OrderDetails.DoesNotExist:
# # #             return Response({"error": "Order ID not found."}, status=status.HTTP_404_NOT_FOUND)
# # #         bom_entries = BomDetails.objects.filter(order=order)
# # #         serializer = BomDetailsSerializer(bom_entries, many=True)
# # #         # Manufacturer summary: just list components per manufacturer
# # #         manufacturer_data = defaultdict(list)
# # #         for entry in bom_entries:
# # #             manufacturer = str(entry.manufacturer or "MNP")
# # #             component = str(entry.component or "CNA")
# # #             manufacturer_data[manufacturer].append(component)

# # #         manufacturer_summary = []
# # #         for manufacturer, components in manufacturer_data.items():
# # #             manufacturer_summary.append({
# # #                 "manufacturer": manufacturer,
# # #                 "components": [{"component_name": comp} for comp in components]
# # #             })
# # #         # Supplier summary: supplier -> list of parts
# # #         supplier_data = defaultdict(list)
# # #         for entry in bom_entries:
# # #             supplier = str(entry.supplier or "SNP")
# # #             supplier_part_no= str(entry.supplier_component or "SCNA")
# # #             unit_price = float(entry.unit_price or 0)
# # #             supplier_data[supplier].append({
# # #                 "supplier_part_no": supplier_part_no,
# # #                 "unit_price": unit_price
# # #             })
# # #         # Format supplier summary
# # #         supplier_summary = []
# # #         for supplier, parts in supplier_data.items():
# # #             total_unit_price = sum(part['unit_price'] for part in parts)
# # #             supplier_summary.append({
# # #                 "supplier": supplier,
# # #                 "parts": parts,
# # #                 "total_unit_price": total_unit_price
# # #             })
# # #         return Response({
# # #             "bom_details": serializer.data,
# # #             "manufacturer_summary": manufacturer_summary,
# # #             "supplier_summary": SupplierSummarySerializer(supplier_summary, many=True).data
# # #         }, status=status.HTTP_200_OK)
# # # class ManufacturerListView(APIView):
# # #     def get(self, request):
# # #         manufacturers = Manufacturers.objects.all()
# # #         serializer = ManufacturerSerializer(manufacturers, many=True)
# # #         return Response(serializer.data, status=status.HTTP_200_OK)
# # # class SupplierListView(APIView):
# # #     def get(self, request):
# # #         suppliers = Suppliers.objects.all()
# # #         serializer = SupplierSerializer(suppliers, many=True)
# # #         return Response(serializer.data, status=status.HTTP_200_OK)
# # # class ComponentOrderIDsView(APIView):
# # #     def get(self, request, *args, **kwargs):
# # #         component_name = request.query_params.get("component_name")
# # #         if not component_name:
# # #             return Response({"error": "component_name parameter is required."}, status=status.HTTP_400_BAD_REQUEST)
# # #         try:
# # #             # Fetch component with case-insensitive exact match
# # #             component = Components.objects.filter(component__iexact=component_name).first()
# # #             if not component:
# # #                 return Response({"error": "Component not found."}, status=status.HTTP_404_NOT_FOUND)
# # #             # Check if component is N/A or similar
# # #             if component.component.strip().lower() in ['cna', 'na', 'n / a','-']:
# # #                 return Response({"error": "Component is not valid (N/A)."}, status=status.HTTP_400_BAD_REQUEST)
# # #             order_ids = (BomDetails.objects
# # #                          .filter(component=component)
# # #                          .values_list("order_id", flat=True)
# # #                          .distinct())
# # #             return Response({
# # #                 "component_name": component.component,
# # #                 "order_ids": list(order_ids),
# # #                 "total_orders": len(order_ids)
# # #             })
# # #         except Exception as e:
# # #             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
# # # class BulkComponentOrderIDsView(APIView):
# # #     def post(self, request, *args, **kwargs):
# # #         components = Components.objects.exclude(component__icontains='CNA')[:100]
# # #         created_data = []
# # #         for component in components:
# # #             # Skip if component name is in any unavailable form
# # #             if component.component.strip().lower() in ['cna', 'na', 'n / a', '-',
# # #                                                      'cnp','npm','na','do not place',
# # #                                                      'do not populate','generic']:
# # #                 continue
# # #             order_ids = (BomDetails.objects
# # #                          .filter(component=component)
# # #                          .values_list("order_id", flat=True)
# # #                          .distinct())
# # #             if len(order_ids) < 2:
# # #                 continue  # Skip if less than 2 orders
# # #             data, created = ComponentOrderData.objects.get_or_create(
# # #                 component_name=component.component,
# # #                 defaults={    
# # #                     'order_ids': list(order_ids),
# # #                     'total_orders': len(order_ids)
# # #                 }
# # #             )
# # #             created_data.append(data)
# # #         serializer = ComponentOrderDataSerializer(created_data, many=True)
# # #         return Response({
# # #             "message": f"Order data stored for {len(created_data)} components (excluding unknown/CNP/low-count).",
# # #             "data": serializer.data
# # #         }, status=status.HTTP_201_CREATED)
# # # class RawDataListAPIView(generics.ListAPIView):
# # #     serializer_class = RawDataSerializer
# # #     def get_queryset(self):
# # #         queryset = RawData.objects.all()
# # #         order_id = self.request.query_params.get('order_id')
# # #         if order_id:
# # #             queryset = queryset.filter(order_id=order_id)
# # #         return queryset

# # #     def list(self, request, *args, **kwargs):
# # #         queryset = self.get_queryset()
# # #         serializer = self.get_serializer(queryset, many=True)
# # #         # Define values you want to count as invalid/missing
# # #         skip_values = ['DNI','DNP','MNP', 'CNA', 'SCNA', 'SNP','-',
# # #                        '#N/A','DNI 1','DNI 2','DNI 3','Do Not Stuff',
# # #                        '-DNI','none','no load','[noparam]','Consigned',
# # #                        'NP','Generic','DO NOT PLACE','DO NOT POPULATE',
# # #                        'NO POP 1','NO POP']
# # #         # Count of each skip value across relevant fields
# # #         type_counts = {}
# # #         for skip_value in skip_values:
# # #             count = queryset.filter(
# # #                 Q(component__iexact=skip_value) |
# # #                 Q(manufacturer__iexact=skip_value) |
# # #                 Q(supplier_part_no__iexact=skip_value) |
# # #                 Q(supplier__iexact=skip_value)
# # #             ).count()
# # #             type_counts[skip_value.lower()] = count
# # #         return Response({
# # #             'order_id': request.query_params.get('order_id'),
# # #             'counts': type_counts,
# # #             'data': serializer.data
# # #         }, status=status.HTTP_200_OK)
# # # class ComponentsWithoutValidManufacturerView(APIView):
# # #     def get(self, request):
# # #         # Define skip values for manufacturer and component
# # #         invalid_manufacturers = ['mpi', 'dpi', 'dnp', 'mnp', '-', '#N/A','Consigned']
# # #         invalid_components = ['cna', '-', '#N/A','N/A', 'n/a', 'dnp','dni1','dni2','dni3',
# # #                               'Do Not Stuff','-DNI','none','no load','[noparam]','none',
# # #                               'no load','[noparam]','Consigned','NP','Generic',
# # #                               'DO NOT PLACE','DO NOT POPULATE','NO POP 1','NO POP']                                                                                                                           
# # #         # Build case-insensitive OR filter for invalid manufacturers
# # #         manufacturer_q = Q()
# # #         for name in invalid_manufacturers:
# # #             manufacturer_q |= Q(manufacturer__iexact=name)
# # #         # Build exclusion Q for components (case-insensitive)
# # #         component_q = Q()
# # #         for cname in invalid_components:
# # #             component_q |= Q(component__iexact=cname)
# # #         # Filter RawData with case-insensitive matching for invalid manufacturers and excluding invalid components
# # #         filtered_data = RawData.objects.filter(
# # #             manufacturer_q
# # #         ).exclude(
# # #             component_q
# # #         ).values('component', 'manufacturer')
# # #         return Response(list(filtered_data), status=status.HTTP_200_OK)
# # # class ComponentWithoutSupplierView(APIView):
# # #     def get(self, request):
# # #         # Define skip values for Supplier and component
# # #         invalid_supplier = ['dpi', 'dnp', 'snp', '-', '#N/A']
# # #         invalid_components = ['cna', '-', '#N/A','N/A', 'n/a', 'dnp','dni1','dni2','dni3','Do Not Stuff','-DNI','none','no load','[noparam]','none','no load','[noparam]','Consigned','NP','Generic','DO NOT PLACE','DO NOT POPULATE','NO POP 1','NO POP']
# # #  # Build case-insensitive OR filter for invalid supplier
# # #         supplier_q = Q()
# # #         for name in invalid_supplier:
# # #             supplier_q |= Q(supplier__iexact=name)
# # #         # Build exclusion Q for components (case-insensitive)
# # #         component_q = Q()
# # #         for cname in invalid_components:
# # #             component_q |= Q(component__iexact=cname)
# # #         # Filter RawData with case-insensitive matching for invalid supplier and excluding invalid components
# # #         filtered_data = RawData.objects.filter(
# # #             supplier_q
# # #         ).exclude(
# # #             component_q
# # #         ).values('component', 'supplier')
# # #         return Response(list(filtered_data), status=status.HTTP_200_OK)
# # # class BomDataRawByOrderView(APIView):
# # #     def get(self, request, order_id):
# # #         try:
# # #             order = OrderDetails.objects.get(order_id=order_id)
# # #         except OrderDetails.DoesNotExist:
# # #             return Response({"error": "Order not found"}, status=404)
# # #         queryset = BomDataRaw.objects.filter(order=order)
# # #         serializer = BomDataRawSerializer(queryset, many=True)
# # #         return Response(serializer.data, status=200)

# # # from rest_framework.views import APIView
# # # from rest_framework.response import Response
# # # from rest_framework import status
# # # from .models import OrderDetails, BomDataRaw
# # # from .serializers import BomDataRawSerializer, BomDataRawSerializer
# # # from .service import paginate_queryset

# # # class OrderSearchAPIView(APIView):
# # #     def post(self, request):
# # #         order_id = request.data.get('order_id')
# # #         if not order_id:
# # #             return Response({'error': 'order_id is required'}, status=status.HTTP_400_BAD_REQUEST)

# # #         bom_qs = BomDataRaw.objects.filter(order_id=order_id)
# # #         order_details = OrderDetails.objects.filter(order_id=order_id).first()

# # #         if not bom_qs.exists():
# # #             return Response({'message': f'No BOM data found for Order ID: {order_id}'}, status=404)

# # #         page = request.GET.get('page', 1)
# # #         paginated = paginate_queryset(bom_qs, page)
# # #         return Response({
# # #             'bom_data': BomDataRawSerializer(paginated, many=True).data,
# # #             'order_details': BomDataRawSerializer(order_details).data if order_details else None
# # #         })
# # # class ComponentSearchAPIView(APIView):
# # #     def post(self, request):
# # #         part_number = request.data.get('part_number', '').strip()
# # #         if not part_number:
# # #             return Response({'error': 'part_number is required'}, status=400)

# # #         result, source = fetch_or_cache_component_data(request, part_number)
# # #         return Response({
# # #             'component': result,
# # #             'source': source
# # #         })
# # # class UploadedOrderSummaryAPIView(APIView):
# # #     def get(self, request):
# # #         order_id = request.query_params.get('uploaded_order_id')
# # #         if not order_id:
# # #             return Response({'error': 'uploaded_order_id is required'}, status=400)

# # #         try:
# # #             all_results, order_details = get_bom_data_by_order(order_id)
# # #             if not all_results.exists():
# # #                 return Response({'message': 'No data found'}, status=404)

# # #             summary = calculate_bom_summary(all_results)
# # #             return Response({
# # #                 'order_id': order_id,
# # #                 'summary': summary,
# # #                 'order_details': BomDataRawSerializer(order_details).data
# # #             })
# # #         except Exception as e:
# # #             return Response({'error': str(e)}, status=500)


# # # class OrderListAPIView(APIView):
# # #     def get(self, request):
# # #         filter_order_id = request.query_params.get('filter_order_id')
# # #         from_date = request.query_params.get('from_date')
# # #         to_date = request.query_params.get('to_date')

# # #         queryset = get_filtered_orders(filter_order_id, from_date, to_date)
# # #         page = request.query_params.get('page', 1)
# # #         paginated = paginate_queryset(queryset, page, 10)
# # #         return Response({
# # #             'orders': BomDataRawSerializer(paginated, many=True).data
# # #         })

# # # def signup_view(request):
# # #     if request.method == 'POST':
# # #         form = SignUpForm(request.POST)
# # #         if form.is_valid():
# # #             # Save the user data
# # #             user = form.save(commit=False)
# # #             user.set_password(form.cleaned_data['password'])  # Set the password hash
# # #             user.save()  # Save the user to the database

# # #             # Add a success message
# # #             messages.success(request, 'Account created successfully!')
# # #             return redirect('login')  # Redirect to login page after successful signup
# # #     else:
# # #         form = SignUpForm()
# # #     return render(request, 'accounts/signup.html', {'form': form})
# # # def login_view(request):
# # #     if request.method == 'POST':
# # #         username = request.POST['username']
# # #         password = request.POST['password'] 
# # #         # Authenticate user
# # #         user = authenticate(request, username=username, password=password)
# # #         if user is not None:
# # #             # Login the user
# # #             login(request, user)
# # #             messages.success(request, "Login successful!")
# # #             # Redirect to the file upload page after login
# # #             return redirect('uploadf')  # 'uploadfile' should be the name of your file upload URL pattern
# # #         else:
# # #             messages.error(request, "Invalid credentials")
# # #             # Return the login form with error message
# # #             return render(request, 'accounts/login.html', {'error': 'Invalid credentials'}) 
# # #     # Handle GET request or initial load of the login page
# # #     return render(request, 'accounts/login.html')
# # # def logout_view(request):
# # #     logout(request)
# # #     return redirect('login')
# # # def upload_view(request):
# # #     if request.method == 'POST':
# # #         # Handle file upload logic
# # #         form = UploadFileForm(request.POST, request.FILES)
# # #         if form.is_valid():
# # #             # Process the file
# # #             return redirect('success')  # Redirect after successful upload
# # #     else:
# # #         # Handle GET request to display the form
# # #         form = UploadFileForm()
# # #     return render(request, 'uploadf.html', {'form': form})
# # # from urllib.parse import urlencode
# # # def build_query_params(request, exclude_params=None):
# # #     """Helper function to build query parameters for pagination"""
# # #     if exclude_params is None:
# # #         exclude_params = []    
# # #     params = {}
# # #     for key, value in request.GET.items():
# # #         if key not in exclude_params and value:
# # #             params[key] = value   
# # #     return urlencode(params)


# # # def upload_file(request):
# # #     search_results = None
# # #     processed_data = None
# # #     order_id = None
# # #     order_details = None
# # #     unique_components_count = 0
# # #     part_not_found = 0
# # #     do_not_populate = 0
# # #     part_consigned = 0
# # #     form = UploadFileForm()
# # #     order_search_form = OrderSearchForm()
# # #     component_search_results = None
# # #     component_search_source = None
# # #     uploaded_order_id = request.session.get('uploaded_order_id')
# # #     excluded_keys = [
# # #         "Manufacturer", "ManufacturerPartNumber", "MouserPartNumber", "Category",
# # #         "Min", "Availability", "FactoryStock", "LeadTime", "AvailabilityInStock",
# # #         "PriceBreaks", "ProductAttributes", "DataSheetUrl", "ProductDetailUrl",
# # #         "AlternatePackagings", "ProductCompliance", "Description", "ROHSStatus", "ImagePath"
# # #     ]
# # #     if request.method == 'POST':
# # #         if 'file_upload' in request.POST:
# # #             form = UploadFileForm(request.POST, request.FILES)
# # #             if not request.FILES.get('file'):
# # #                 messages.error(request, "No file selected.")
# # #                 return redirect('uploadf')
# # #             if form.is_valid():
# # #                 uploaded_file = form.cleaned_data['file']
# # #                 ext = os.path.splitext(uploaded_file.name)[1].lower()
# # #                 if ext not in ['.xls', '.xlsx', '.csv']:
# # #                     messages.error(request, "Invalid file type.")
# # #                     return redirect('uploadf')
# # #                 try:
# # #                     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
# # #                         for chunk in uploaded_file.chunks():
# # #                             tmp.write(chunk)
# # #                         tmp_path = tmp.name
# # #                     processed_data = parse_excel_file(tmp_path, request, original_filename=uploaded_file.name)
# # #                     order_id = processed_data.get('order_id')
# # #                     save_parsed_data(processed_data, tmp_path)
# # #                     request.session['uploaded_order_id'] = order_id
# # #                     request.session['show_upload_summary'] = True
# # #                     os.remove(tmp_path)
# # #                     messages.success(request, f"File processed. Order ID: {order_id}")
# # #                     return redirect(f'/uploadf/?show_upload_form=1&uploaded_order_id={order_id}')
# # #                 except Exception as e:
# # #                     if 'tmp_path' in locals() and os.path.exists(tmp_path):
# # #                         os.remove(tmp_path)
# # #                     messages.error(request, f"Processing error: {str(e)}")
# # #                     return redirect('uploadf')
# # #         elif 'order_search' in request.POST:
# # #             order_search_form = OrderSearchForm(request.POST)
# # #             if order_search_form.is_valid():
# # #                 order_id = order_search_form.cleaned_data.get('order_id')
# # #                 all_results = BomDataRaw.objects.filter(order_id=order_id)
# # #                 page = request.GET.get('page', 1)
# # #                 search_results = paginate_queryset(all_results, page)
# # #                 order_details = OrderDetails.objects.filter(order_id=order_id).first()
# # #                 if not all_results.exists():
# # #                     messages.warning(request, f"No BOM data found for Order ID: {order_id}")
# # #         elif 'component_search_submit' in request.POST:
# # #             part_number = request.POST.get('component_search', '').strip()
# # #             component_search_results, component_search_source = fetch_or_cache_component_data(request, part_number)
# # #     uploaded_order_id_param = request.GET.get('uploaded_order_id')
# # #     if uploaded_order_id_param or (request.GET.get('show_upload_form') and uploaded_order_id):
# # #         display_order_id = uploaded_order_id_param or uploaded_order_id
# # #         if display_order_id:
# # #             try:
# # #                 all_results, order_details = get_bom_data_by_order(display_order_id)
# # #                 if all_results.exists():
# # #                     page = request.GET.get('page', 1)
# # #                     search_results = paginate_queryset(all_results, page)
# # #                     summary = calculate_bom_summary(all_results)
# # #                     unique_components_count = summary["unique_components_count"]
# # #                     part_not_found = summary["part_not_found"]
# # #                     do_not_populate = summary["do_not_populate"]
# # #                     part_consigned = summary["part_consigned"]
# # #                     order_id = display_order_id
# # #             except Exception as e:
# # #                 messages.error(request, f"Error loading uploaded data: {str(e)}")
# # #     # Filters
# # #     filter_order_id = request.GET.get('filter_order_id')
# # #     from_date = request.GET.get('from_date')
# # #     to_date = request.GET.get('to_date')
# # #     all_orders_query = get_filtered_orders(filter_order_id, from_date, to_date)
# # #     orders_page = request.GET.get('orders_page', 1)
# # #     all_orders = paginate_queryset(all_orders_query, orders_page, 10)
# # #     # BOM Data tab
# # #     selected_order_id = request.GET.get('order_id')
# # #     bom_data = None
# # #     if selected_order_id:
# # #         try:
# # #             order = OrderDetails.objects.get(order_id=selected_order_id)
# # #             all_bom_data = BomDataRaw.objects.filter(order=order)
# # #             bom_page = request.GET.get('bom_page', 1)
# # #             bom_data = paginate_queryset(all_bom_data, bom_page, 20)
# # #         except OrderDetails.DoesNotExist:
# # #             bom_data = []
# # #     # Query params
# # #     component_search_query = request.GET.get('component_search', '').strip()
# # #     search_query_params = build_query_params(request, exclude_params=['page'])
# # #     orders_query_params = build_query_params(request, exclude_params=['orders_page'])
# # #     bom_query_params = build_query_params(request, exclude_params=['bom_page'])
# # #     return render(request, 'uploadf.html', {
# # #         'form': form,
# # #         'order_search_form': order_search_form,
# # #         'processed_data': processed_data,
# # #         'search_results': search_results,
# # #         'order_details': order_details,
# # #         'all_orders': all_orders,
# # #         'bom_data': bom_data,
# # #         'selected_order_id': selected_order_id,
# # #         'unique_components_count': unique_components_count,
# # #         'part_not_found': part_not_found,
# # #         'do_not_populate': do_not_populate,
# # #         'part_consigned': part_consigned,
# # #         'filter_order_id': filter_order_id,
# # #         'from_date': from_date,
# # #         'to_date': to_date,
# # #         'component_search_results': component_search_results,
# # #         'component_search_query': component_search_query,
# # #         'component_search_source': component_search_source,
# # #         'search_query_params': search_query_params,
# # #         'orders_query_params': orders_query_params,
# # #         'bom_query_params': bom_query_params,
# # #         'excluded_keys': excluded_keys,
# # #         'uploaded_order_id': uploaded_order_id_param or uploaded_order_id,
# # #     })


# # # def parse_data_field(results):
# # #     for r in results:
# # #         if isinstance(r.get('data'), str):
# # #             try:
# # #                 r['data'] = json.loads(r['data'])
# # #             except json.JSONDecodeError:
# # #                 r['data'] = {}
# # #     return results



# # # def component_detail_view(request, component_name):
# # #     parsed_results = []

# # #     # ðŸ”¹ Handle external fetch when "Get Data" button is submitted
# # #     if request.method == 'POST' and request.POST.get('force_external') == '1':
# # #         part_number = request.POST.get('manufacturer_part_number')

# # #         # Fetch from Mouser/OEMSecrets
# # #         result = search_component_by_part_number(part_number)

# # #         if 'error' in result:
# # #             messages.error(request, result['error'])
# # #             context = {
# # #                 'component_search_query': component_name,
# # #                 'component_search_results': None,
# # #                 'component_search_source': 'None',
# # #                 'show_get_data_button': True
# # #             }
# # #             return render(request, 'componentdetails.html', context)
# # #         else:
# # #             # Simulate a DB object for rendering
# # #             part = PartSearchData(
# # #                 manufacturer_part_number=part_number,
# # #                 data=result['data'],
# # #                 source=result['source']
# # #             )
# # #             part.parsed_data = result['data']
# # #             parsed_results.append(part)

# # #             messages.success(request, f"Data fetched from {result['source']}.")
# # #             context = {
# # #                 'component_search_query': component_name,
# # #                 'component_search_results': parsed_results,
# # #                 'component_search_source': result['source'],
# # #                 'show_get_data_button': False
# # #             }
# # #             return render(request, 'componentdetails.html', context)

# # #     # ðŸ”¹ Handle normal GET â€” check in DB
# # #     results = PartSearchData.objects.filter(manufacturer_part_number__iexact=component_name)
# # #     if results.exists():
# # #         for part in results:
# # #             try:
# # #                 # Parse JSON data
# # #                 if part.data:
# # #                     parsed_data = json.loads(part.data) if isinstance(part.data, str) else part.data
# # #                     part.parsed_data = parsed_data
# # #                 else:
# # #                     part.parsed_data = {}
# # #             except (json.JSONDecodeError, ValidationError) as e:
# # #                 part.parsed_data = {}
# # #                 part.json_error = str(e)
# # #             parsed_results.append(part)

# # #     context = {
# # #         'component_search_query': component_name,
# # #         'component_search_results': parsed_results if parsed_results else None,
# # #         'component_search_source': 'Database' if parsed_results else 'None',
# # #         'show_get_data_button': not parsed_results
# # #     }
# # #     return render(request, 'componentdetails.html', context)

# # # def handle_uploaded_file(uploaded_file):
# # #     # Get file extension from the uploaded file name
# # #     ext = os.path.splitext(uploaded_file.name)[1]
# # #     # Save uploaded file to a temporary file
# # #     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
# # #         for chunk in uploaded_file.chunks():  # Write in chunks for large files
# # #             tmp.write(chunk)
# # #         tmp_path = tmp.name  # This is the file path to pass
# # #     return tmp_path
# # # # refer/api/views.py
# # # def component_search_view(request):
# # #     result = None
# # #     not_found = False
# # #     if request.method == 'POST':
# # #         form = ComponentSearchForm(request.POST)
# # #         if form.is_valid():
# # #             part_number = form.cleaned_data['manufacturer_part_number']
# # #             currency = form.cleaned_data.get('currency') or 'USD'
# # #             country_code = form.cleaned_data.get('country_code') or 'AT'
# # #             result = search_component_by_part_number(part_number, currency, country_code)
# # #             if 'error' in result:
# # #                 not_found = True
# # #     else:
# # #         form = ComponentSearchForm()
# # #     return render(request, 'component_search.html', {
# # #         'form': form,
# # #         'result': result,
# # #         'not_found': not_found
# # #     })



# # # logger = logging.getLogger(__name__)
# # # # class MouserSearchAPIView(APIView):
# # # #     def get(self, request):
# # # #         part_number = request.query_params.get('part_number')
# # # #         if not part_number:
# # # #             return Response({"error": "part_number query parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

# # # #         part_data = search_mouser_component(part_number)
# # # #         if part_data:
# # # #             return Response(part_data)
# # # #         else:
# # # #             return Response({"message": "Part not found or error in Mouser API."}, status=status.HTTP_404_NOT_FOUND)


# # # # class OEMSecretsPartSearchView(APIView):
# # # #     def get(self, request):
# # # #         part_number = request.query_params.get('part_number')
# # # #         currency = request.query_params.get('currency', 'USD')
# # # #         country_code = request.query_params.get('country_code', 'AT')

# # # #         if not part_number:
# # # #             return Response({'error': 'part_number parameter is required'}, status=status.HTTP_400_BAD_REQUEST)

# # # #         data, error = fetch_from_oem_secrets(part_number, currency, country_code)
# # # #         if error:
# # # #             return Response(error, status=status.HTTP_502_BAD_GATEWAY)
# # # #         return Response(data, status=status.HTTP_200_OK)


# # # # class CombinedPartSearchAPIView(APIView):
# # # #     def get(self, request):
# # # #         part_number = request.query_params.get('part_number')
# # # #         currency = request.query_params.get('currency', 'USD')
# # # #         country_code = request.query_params.get('country_code', 'AT')

# # # #         if not part_number:
# # # #             return Response({'error': 'part_number query parameter is required.'}, status=status.HTTP_400_BAD_REQUEST)

# # # #         # Step 1: Try Mouser
# # # #         mouser_data = search_mouser_component(part_number)
# # # #         if mouser_data:
# # # #             return Response({
# # # #                 "source": "Mouser",
# # # #                 "data": mouser_data
# # # #             }, status=status.HTTP_200_OK)

# # # #         # Step 2: Fallback to OEMSecrets
# # # #         data, error = fetch_from_oem_secrets(part_number, currency, country_code)
# # # #         if error:
# # # #             return Response(error, status=status.HTTP_502_BAD_GATEWAY)
# # # #         return Response({
# # # #             "source": "OEMSecrets",
# # # #             "data": data
# # # #         }, status=status.HTTP_200_OK)



# # # from django.http import JsonResponse, HttpResponse
# # # from django.db.models import Q
# # # from django.core.paginator import Paginator
# # # from .models import ComponentCrons, ComponentPrice
# # # from datetime import datetime, timedelta, date
# # # import json
# # # import matplotlib
# # # matplotlib.use('Agg')  # Use non-interactive backend
# # # import matplotlib.pyplot as plt
# # # import matplotlib.dates as mdates
# # # from matplotlib.figure import Figure
# # # import io
# # # import base64
# # # import pandas as pd
# # # import numpy as np
# # # from collections import defaultdict
# # # import logging

# # # logger = logging.getLogger(__name__)

# # # def component_list(request):
# # #     """View to display all components with search functionality"""
# # #     search_query = request.GET.get('search', '')
# # #     page_number = request.GET.get('page', 1)
    
# # #     # Get unique components from ComponentCrons
# # #     components = ComponentCrons.objects.values('component_name').distinct()
    
# # #     if search_query:
# # #         components = components.filter(component_name__icontains=search_query)
    
# # #     # Get additional details for each component
# # #     component_list = []
# # #     for comp in components:
# # #         component_name = comp['component_name']
# # #         latest_entry = ComponentCrons.objects.filter(
# # #             component_name=component_name
# # #         ).order_by('-fetched_at').first()
        
# # #         # Get latest price
# # #         latest_price = ComponentPrice.objects.filter(
# # #             part_number=component_name
# # #         ).order_by('-date', 'quantity').first()
        
# # #         component_list.append({
# # #             'name': component_name,
# # #             'source': latest_entry.source if latest_entry else 'Unknown',
# # #             'last_updated': latest_entry.fetched_at if latest_entry else None,
# # #             'latest_price': latest_price.price if latest_price else None,
# # #             'currency': latest_price.currency if latest_price else 'USD',
# # #             'data_points': ComponentPrice.objects.filter(part_number=component_name).count()
# # #         })
        
# # #     # Paginate results
# # #     paginator = Paginator(component_list, 20)  # Show 20 components per page
# # #     page_obj = paginator.get_page(page_number)
    
# # #     context = {
# # #         'components': page_obj,
# # #         'search_query': search_query,
# # #         'total_components': len(component_list)
# # #     }
    
# # #     return render(request, 'component_list.html', context)

# # # def generate_price_graphs(component_name, days=30):
# # #     """Generate matplotlib graphs for component price data with all quantities on one chart"""
# # #     try:
# # #         # Calculate the exact start date
# # #         today = date.today()
# # #         start_date = today - timedelta(days=days)
        
# # #         logger.info(f"Generating graphs for {component_name}")
# # #         logger.info(f"Date range: {start_date} to {today} ({days} days)")
        
# # #         # Filter price data with exact date range
# # #         price_data = ComponentPrice.objects.filter(
# # #             part_number=component_name,
# # #             date__gte=start_date,
# # #             date__lte=today
# # #         ).order_by('date', 'quantity')
        
# # #         logger.info(f"Found {price_data.count()} price records")
        
# # #         if not price_data.exists():
# # #             logger.warning(f"No price data found for {component_name} in date range {start_date} to {today}")
# # #             return None, None, []
        
# # #         # Debug: Print actual date range of data
# # #         actual_dates = price_data.values_list('date', flat=True).distinct().order_by('date')
# # #         if actual_dates:
# # #             logger.info(f"Actual data dates: {list(actual_dates)[:5]}...{list(actual_dates)[-5:]}")
        
# # #         # Group data by quantity
# # #         quantity_data = defaultdict(list)
# # #         for price in price_data:
# # #             quantity_data[price.quantity].append({
# # #                 'date': price.date,
# # #                 'price': float(price.price),
# # #                 'currency': price.currency
# # #             })
        
# # #         # Sort quantities for consistent ordering
# # #         sorted_quantities = sorted(quantity_data.keys())
# # #         currency = price_data.first().currency
        
# # #         if len(sorted_quantities) == 0:
# # #             return None, None, []
        
# # #         logger.info(f"Processing {len(sorted_quantities)} different quantities: {sorted_quantities}")
        
# # #         # Set matplotlib style for better appearance
# # #         plt.style.use('default')
# # #         plt.rcParams.update({
# # #             'figure.facecolor': 'white',
# # #             'axes.facecolor': 'white',
# # #             'font.size': 12,
# # #             'axes.titlesize': 16,
# # #             'axes.labelsize': 14,
# # #             'xtick.labelsize': 12,
# # #             'ytick.labelsize': 12,
# # #             'legend.fontsize': 11
# # #         })
        
# # #         # Create single figure for all quantities
# # #         fig, ax = plt.subplots(figsize=(16, 10))
        
# # #         # Modern color palette - more colors for different quantities
# # #         colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
# # #                   '#06B6D4', '#84CC16', '#F97316', '#EC4899', '#6366F1',
# # #                   '#14B8A6', '#F472B6', '#A855F7', '#22D3EE', '#FDE047']
        
# # #         # Plot each quantity as a separate line
# # #         graphs_data = []
        
# # #         for idx, quantity in enumerate(sorted_quantities):
# # #             data = quantity_data[quantity]
# # #             dates = [item['date'] for item in data]
# # #             prices = [item['price'] for item in data]
            
# # #             logger.info(f"Quantity {quantity}: {len(dates)} data points from {min(dates) if dates else 'N/A'} to {max(dates) if dates else 'N/A'}")
            
# # #             # Plot the line for this quantity
# # #             color = colors[idx % len(colors)]
# # #             ax.plot(dates, prices, 
# # #                    marker='o', 
# # #                    linewidth=3, 
# # #                    markersize=6, 
# # #                    color=color, 
# # #                    label=f'{quantity:,} pcs',
# # #                    markerfacecolor='white', 
# # #                    markeredgewidth=2, 
# # #                    markeredgecolor=color,
# # #                    alpha=0.8)
            
# # #             # Store graph data for summary
# # #             if len(prices) > 0:
# # #                 graphs_data.append({
# # #                     'quantity': quantity,
# # #                     'min_price': min(prices),
# # #                     'max_price': max(prices),
# # #                     'avg_price': sum(prices) / len(prices),
# # #                     'data_points': len(prices),
# # #                     'currency': currency,
# # #                     'date_range': f"{min(dates).strftime('%m/%d')} - {max(dates).strftime('%m/%d')}"
# # #                 })
        
# # #         # Customize the main chart
# # #         title = f'Price Trends for {component_name}\n({start_date.strftime("%b %d, %Y")} to {today.strftime("%b %d, %Y")} - {days} days)'
# # #         ax.set_title(title, fontsize=18, fontweight='bold', pad=30)
# # #         ax.set_xlabel('Date', fontsize=14, fontweight='500')
# # #         ax.set_ylabel(f'Price ({currency})', fontsize=14, fontweight='500')
# # #         ax.grid(True, alpha=0.3, linestyle='--')
# # #         ax.set_facecolor('#FAFAFA')
        
# # #         # Format x-axis dates based on the time period
# # #         if len(actual_dates) > 0:
# # #             # Use actual dates for x-axis positioning to reduce gaps
# # #             ax.set_xlim(min(actual_dates), max(actual_dates))
            
# # #             if days <= 7:
# # #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# # #                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
# # #             elif days <= 30:
# # #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# # #                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(actual_dates)//8)))
# # #             elif days <= 90:
# # #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# # #                 ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=max(1, len(actual_dates)//10)))
# # #             else:
# # #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%y'))
# # #                 ax.xaxis.set_major_locator(mdates.MonthLocator(interval=max(1, len(actual_dates)//8)))
            
# # #             plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
# # #         # Reduce margins for tighter layout
# # #         ax.margins(x=0.01, y=0.05)  # Reduced x-margin from 0.02 to 0.01
        
# # #         # Add legend with better positioning
# # #         legend = ax.legend(loc='upper left', 
# # #                           bbox_to_anchor=(0.02, 0.98),
# # #                           frameon=True, 
# # #                           fancybox=True, 
# # #                           shadow=True,
# # #                           ncol=min(3, len(sorted_quantities)),  # Max 3 columns
# # #                           fontsize=11)
# # #         legend.get_frame().set_facecolor('white')
# # #         legend.get_frame().set_alpha(0.9)
        
# # #         # Style the axes
# # #         ax.spines['top'].set_visible(False)
# # #         ax.spines['right'].set_visible(False)
# # #         ax.spines['left'].set_color('#E5E7EB')
# # #         ax.spines['bottom'].set_color('#E5E7EB')
        
# # #         # Add some padding to the plot
        
        
# # #         plt.tight_layout()
# # #         plt.subplots_adjust(top=0.85, bottom=0.15, left=0.08, right=0.95)  # Tighter layout
        
# # #         # Convert plot to base64 string
# # #         buffer = io.BytesIO()
# # #         plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight', 
# # #                     facecolor='white', edgecolor='none', pad_inches=0.3)
# # #         buffer.seek(0)
# # #         image_base64 = base64.b64encode(buffer.getvalue()).decode()
# # #         plt.close()
        
# # #         # Create summary statistics graph (bar chart)
# # #         summary_image_base64 = None
# # #         if len(graphs_data) > 1:  # Only create summary if multiple quantities
# # #             try:
# # #                 summary_fig, summary_ax = plt.subplots(figsize=(14, 8))
# # #                 summary_fig.patch.set_facecolor('white')
                
# # #                 # Prepare data for summary graph
# # #                 quantities_list = [data['quantity'] for data in graphs_data]
# # #                 avg_prices = [data['avg_price'] for data in graphs_data]
# # #                 min_prices = [data['min_price'] for data in graphs_data]
# # #                 max_prices = [data['max_price'] for data in graphs_data]
                
# # #                 x = np.arange(len(quantities_list))
# # #                 width = 0.25
                
# # #                 # Create grouped bar chart with modern styling
# # #                 bars1 = summary_ax.bar(x - width, min_prices, width, label='Min Price', 
# # #                                       color='#10B981', alpha=0.8, edgecolor='white', linewidth=2)
# # #                 bars2 = summary_ax.bar(x, avg_prices, width, label='Avg Price', 
# # #                                       color='#3B82F6', alpha=0.8, edgecolor='white', linewidth=2)
# # #                 bars3 = summary_ax.bar(x + width, max_prices, width, label='Max Price', 
# # #                                       color='#EF4444', alpha=0.8, edgecolor='white', linewidth=2)
                
# # #                 summary_ax.set_xlabel('Quantity (pieces)', fontsize=12, fontweight='500')
# # #                 summary_ax.set_ylabel(f'Price ({currency})', fontsize=12, fontweight='500')
# # #                 summary_ax.set_title(f'Price Summary for {component_name}\n({start_date.strftime("%b %d")} - {today.strftime("%b %d, %Y")})', 
# # #                                     fontsize=16, fontweight='bold', pad=20)
# # #                 summary_ax.set_xticks(x)
# # #                 summary_ax.set_xticklabels([f'{q:,}' for q in quantities_list])
# # #                 summary_ax.legend(frameon=False, loc='upper left')
# # #                 summary_ax.grid(True, alpha=0.3, axis='y', linestyle='--')
# # #                 summary_ax.set_facecolor('#FAFAFA')
                
# # #                 # Style the axes
# # #                 summary_ax.spines['top'].set_visible(False)
# # #                 summary_ax.spines['right'].set_visible(False)
# # #                 summary_ax.spines['left'].set_color('#E5E7EB')
# # #                 summary_ax.spines['bottom'].set_color('#E5E7EB')
                
# # #                 # Add value labels on bars
# # #                 def add_value_labels(bars, values):
# # #                     for bar, value in zip(bars, values):
# # #                         height = bar.get_height()
# # #                         summary_ax.text(bar.get_x() + bar.get_width()/2., height + max(max_prices) * 0.02,
# # #                                        f'{value:.2f}', ha='center', va='bottom', fontsize=10, fontweight='bold')
                
# # #                 add_value_labels(bars1, min_prices)
# # #                 add_value_labels(bars2, avg_prices)
# # #                 add_value_labels(bars3, max_prices)
                
# # #                 plt.tight_layout()
                
# # #                 # Convert summary plot to base64 string
# # #                 summary_buffer = io.BytesIO()
# # #                 plt.savefig(summary_buffer, format='png', dpi=200, bbox_inches='tight',
# # #                            facecolor='white', edgecolor='none', pad_inches=0.2)
# # #                 summary_buffer.seek(0)
# # #                 summary_image_base64 = base64.b64encode(summary_buffer.getvalue()).decode()
# # #                 plt.close()
# # #             except Exception as e:
# # #                 logger.error(f"Error creating summary graph: {e}")
# # #                 summary_image_base64 = None
        
# # #         logger.info(f"Successfully generated graphs for {component_name} with {len(graphs_data)} quantities")
# # #         return image_base64, summary_image_base64, graphs_data
        
# # #     except Exception as e:
# # #         logger.error(f"Error generating graphs for {component_name}: {e}")
# # #         return None, None, []

# # # def component_price_graph(request, component_name):
# # #     """View to display price graph for a specific component"""
# # #     try:
# # #         component = ComponentCrons.objects.filter(component_name=component_name).first()
# # #     except Exception as e:
# # #         logger.error(f"Error fetching component {component_name}: {e}")
# # #         component = None
    
# # #     # Get the number of days from request - default to 30
# # #     days = int(request.GET.get('days', 30))
# # #     logger.info(f"Loading component_price_graph for {component_name}, days: {days}")
    
# # #     # Generate graphs
# # #     price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
    
# # #     # Get component details
# # #     latest_entry = ComponentCrons.objects.filter(
# # #         component_name=component_name
# # #     ).order_by('-fetched_at').first()
    
# # #     # Get currency info
# # #     latest_price = ComponentPrice.objects.filter(
# # #         part_number=component_name
# # #     ).order_by('-date').first()
    
# # #     context = {
# # #         'component_name': component_name,
# # #         'component': latest_entry,
# # #         'price_graph': price_graph,
# # #         'summary_graph': summary_graph,
# # #         'graphs_data': graphs_data,
# # #         'currency': latest_price.currency if latest_price else 'USD',
# # #         'selected_days': days,
# # #         'has_data': price_graph is not None
# # #     }
    
# # #     logger.info(f"Context: has_data={context['has_data']}, selected_days={context['selected_days']}")
# # #     return render(request, 'component_price_graph.html', context)

# # # def component_price_api(request, component_name):
# # #     """API endpoint to get price data for AJAX requests"""
# # #     days = int(request.GET.get('days', 30))
# # #     logger.info(f"API call for {component_name}, days: {days}")
    
# # #     try:
# # #         # Generate new graphs with the requested time period
# # #         price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
        
# # #         response_data = {
# # #             'price_graph': price_graph,
# # #             'summary_graph': summary_graph,
# # #             'graphs_data': graphs_data,
# # #             'has_data': price_graph is not None,
# # #             'currency': graphs_data[0]['currency'] if graphs_data else 'USD',
# # #             'days': days  # Include the actual days processed
# # #         }
        
# # #         logger.info(f"API response: has_data={response_data['has_data']}, days={days}")
# # #         return JsonResponse(response_data)
        
# # #     except Exception as e:
# # #         logger.error(f"API error for {component_name}: {e}")
# # #         return JsonResponse({
# # #             'error': str(e),
# # #             'has_data': False,
# # #             'price_graph': None,
# # #             'summary_graph': None,
# # #             'graphs_data': [],
# # #             'days': days
# # #         }, status=500)


# # from django.shortcuts import render, redirect
# # from django.contrib.auth import authenticate, login, logout
# # from rest_framework import generics
# # from django.db.models import Q
# # from rest_framework.views import APIView
# # from rest_framework.response import Response
# # from rest_framework.parsers import MultiPartParser, FormParser
# # from rest_framework import status
# # from .models import (
# #     Excelfile,OrderDetails,Manufacturers,Components,Suppliers,BomDetails,ComponentOrderData,RawData,BomDataRaw,
# # )
# # from .serializers import (
# #     ExcelFileSerializer,BomDetailsSerializer,SupplierSummarySerializer,ManufacturerSerializer, ComponentOrderDataSerializer,SupplierSerializer,RawDataSerializer,BomDataRawSerializer,
# # )
# # import warnings
# # import logging
# # from django.http import HttpResponse
# # from collections import defaultdict
# # from .serializers import ExcelFileSerializer  # Import your serializer
# # from django.contrib.auth import authenticate, login
# # from django.contrib.auth import logout
# # import os
# # import tempfile
# # from django.contrib import messages
# # from .process_excel_file import process_excel_file, parse_excel_file, save_parsed_data
# # # Optional: suppress future warnings for pandas downcasting
# # from .forms import UploadFileForm, OrderSearchForm, SignUpForm,ComponentSearchForm
# # from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
# # from .service import (
# #     paginate_queryset, calculate_bom_summary,
# #     get_bom_data_by_order, get_filtered_orders,search_component_by_part_number,
# #     search_mouser_component,fetch_from_oem_secrets,fetch_or_cache_component_data,
# #     fetch_or_cache_component_data, paginate_queryset,calculate_bom_summary,   
# # )
# # from .models import PartSearchData
# # import json
# # from django.core.exceptions import ValidationError

# # warnings.simplefilter(action='ignore', category=FutureWarning)
# # logger = logging.getLogger(__name__)

# # def home(request):
# #     return HttpResponse("Welcome to the Excel Upload API. Use /api/upload/ to upload your Excel file.")

# # class UploadExcelView(APIView):
# #     parser_classes = [MultiPartParser, FormParser]  # For file parsing support

# #     def post(self, request, *args, **kwargs):
# #         # Use the serializer to handle the file upload
# #         file_serializer = ExcelFileSerializer(data=request.data)
# #         if file_serializer.is_valid():
# #             # Save the file instance and retrieve the file path
# #             file_instance = file_serializer.save()
# #             excel_file = file_instance.file.path  # Get the file path
# #             # Now process the file and return the response
# #             return process_excel_file(excel_file, request, return_json=True)  # Pass the file path to process the file
# #         # If the serializer is not valid, return the errors
# #         return Response(file_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    
# # class BomByOrderIDView(APIView):
# #     def get(self, request, order_id):
# #         try:
# #             order = OrderDetails.objects.get(order_id=order_id)
# #         except OrderDetails.DoesNotExist:
# #             return Response({"error": "Order ID not found."}, status=status.HTTP_404_NOT_FOUND)

# #         bom_entries = BomDetails.objects.filter(order=order)
# #         serializer = BomDetailsSerializer(bom_entries, many=True)

# #         # Manufacturer summary: just list components per manufacturer
# #         manufacturer_data = defaultdict(list)
# #         for entry in bom_entries:
# #             manufacturer = str(entry.manufacturer or "MNP")
# #             component = str(entry.component or "CNA")
# #             manufacturer_data[manufacturer].append(component)

# #         manufacturer_summary = []
# #         for manufacturer, components in manufacturer_data.items():
# #             manufacturer_summary.append({
# #                 "manufacturer": manufacturer,
# #                 "components": [{"component_name": comp} for comp in components]
# #             })

# #         # Supplier summary: supplier -> list of parts
# #         supplier_data = defaultdict(list)
# #         for entry in bom_entries:
# #             supplier = str(entry.supplier or "SNP")
# #             supplier_part_no= str(entry.supplier_component or "SCNA")
# #             unit_price = float(entry.unit_price or 0)
# #             supplier_data[supplier].append({
# #                 "supplier_part_no": supplier_part_no,
# #                 "unit_price": unit_price
# #             })

# #         # Format supplier summary
# #         supplier_summary = []
# #         for supplier, parts in supplier_data.items():
# #             total_unit_price = sum(part['unit_price'] for part in parts)
# #             supplier_summary.append({
# #                 "supplier": supplier,
# #                 "parts": parts,
# #                 "total_unit_price": total_unit_price,
# #                 "currency": "USD"  # Changed from INR to USD
# #             })

# #         return Response({
# #             "bom_details": serializer.data,
# #             "manufacturer_summary": manufacturer_summary,
# #             "supplier_summary": SupplierSummarySerializer(supplier_summary, many=True).data,
# #             "currency": "USD"  # Changed from INR to USD
# #         }, status=status.HTTP_200_OK)

# # class ManufacturerListView(APIView):
# #     def get(self, request):
# #         manufacturers = Manufacturers.objects.all()
# #         serializer = ManufacturerSerializer(manufacturers, many=True)
# #         return Response(serializer.data, status=status.HTTP_200_OK)

# # class SupplierListView(APIView):
# #     def get(self, request):
# #         suppliers = Suppliers.objects.all()
# #         serializer = SupplierSerializer(suppliers, many=True)
# #         return Response(serializer.data, status=status.HTTP_200_OK)

# # class ComponentOrderIDsView(APIView):
# #     def get(self, request, *args, **kwargs):
# #         component_name = request.query_params.get("component_name")
# #         if not component_name:
# #             return Response({"error": "component_name parameter is required."}, status=status.HTTP_400_BAD_REQUEST)

# #         try:
# #             # Fetch component with case-insensitive exact match
# #             component = Components.objects.filter(component__iexact=component_name).first()
# #             if not component:
# #                 return Response({"error": "Component not found."}, status=status.HTTP_404_NOT_FOUND)

# #             # Check if component is N/A or similar
# #             if component.component.strip().lower() in ['cna', 'na', 'n / a','-']:
# #                 return Response({"error": "Component is not valid (N/A)."}, status=status.HTTP_400_BAD_REQUEST)

# #             order_ids = (BomDetails.objects
# #                          .filter(component=component)
# #                          .values_list("order_id", flat=True)
# #                          .distinct())

# #             return Response({
# #                 "component_name": component.component,
# #                 "order_ids": list(order_ids),
# #                 "total_orders": len(order_ids)
# #             })

# #         except Exception as e:
# #             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# # class BulkComponentOrderIDsView(APIView):
# #     def post(self, request, *args, **kwargs):
# #         components = Components.objects.exclude(component__icontains='CNA')[:100]
# #         created_data = []

# #         for component in components:
# #             # Skip if component name is in any unavailable form
# #             if component.component.strip().lower() in ['cna', 'na', 'n / a', '-',
# #                                                      'cnp','npm','na','do not place',
# #                                                      'do not populate','generic']:
# #                 continue

# #             order_ids = (BomDetails.objects
# #                          .filter(component=component)
# #                          .values_list("order_id", flat=True)
# #                          .distinct())

# #             if len(order_ids) < 2:
# #                 continue  # Skip if less than 2 orders

# #             data, created = ComponentOrderData.objects.get_or_create(
# #                 component_name=component.component,
# #                 defaults={    
# #                     'order_ids': list(order_ids),
# #                     'total_orders': len(order_ids)
# #                 }
# #             )

# #             created_data.append(data)

# #         serializer = ComponentOrderDataSerializer(created_data, many=True)
# #         return Response({
# #             "message": f"Order data stored for {len(created_data)} components (excluding unknown/CNP/low-count).",
# #             "data": serializer.data
# #         }, status=status.HTTP_201_CREATED)

# # class RawDataListAPIView(generics.ListAPIView):
# #     serializer_class = RawDataSerializer

# #     def get_queryset(self):
# #         queryset = RawData.objects.all()
# #         order_id = self.request.query_params.get('order_id')
# #         if order_id:
# #             queryset = queryset.filter(order_id=order_id)
# #         return queryset

# #     def list(self, request, *args, **kwargs):
# #         queryset = self.get_queryset()
# #         serializer = self.get_serializer(queryset, many=True)

# #         # Define values you want to count as invalid/missing
# #         skip_values = ['DNI','DNP','MNP', 'CNA', 'SCNA', 'SNP','-',
# #                        '#N/A','DNI 1','DNI 2','DNI 3','Do Not Stuff',
# #                        '-DNI','none','no load','[noparam]','Consigned',
# #                        'NP','Generic','DO NOT PLACE','DO NOT POPULATE',
# #                        'NO POP 1','NO POP']

# #         # Count of each skip value across relevant fields
# #         type_counts = {}
# #         for skip_value in skip_values:
# #             count = queryset.filter(
# #                 Q(component__iexact=skip_value) |
# #                 Q(manufacturer__iexact=skip_value) |
# #                 Q(supplier_part_no__iexact=skip_value) |
# #                 Q(supplier__iexact=skip_value)
# #             ).count()
# #             type_counts[skip_value.lower()] = count

# #         return Response({
# #             'order_id': request.query_params.get('order_id'),
# #             'counts': type_counts,
# #             'data': serializer.data,
# #             'currency': 'USD'  # Changed from INR to USD
# #         }, status=status.HTTP_200_OK)

# # class ComponentsWithoutValidManufacturerView(APIView):
# #     def get(self, request):
# #         # Define skip values for manufacturer and component
# #         invalid_manufacturers = ['mpi', 'dpi', 'dnp', 'mnp', '-', '#N/A','Consigned']
# #         invalid_components = ['cna', '-', '#N/A','N/A', 'n/a', 'dnp','dni1','dni2','dni3',
# #                               'Do Not Stuff','-DNI','none','no load','[noparam]','none',
# #                               'no load','[noparam]','Consigned','NP','Generic',
# #                               'DO NOT PLACE','DO NOT POPULATE','NO POP 1','NO POP']                                                                                                                           

# #         # Build case-insensitive OR filter for invalid manufacturers
# #         manufacturer_q = Q()
# #         for name in invalid_manufacturers:
# #             manufacturer_q |= Q(manufacturer__iexact=name)

# #         # Build exclusion Q for components (case-insensitive)
# #         component_q = Q()
# #         for cname in invalid_components:
# #             component_q |= Q(component__iexact=cname)

# #         # Filter RawData with case-insensitive matching for invalid manufacturers and excluding invalid components
# #         filtered_data = RawData.objects.filter(
# #             manufacturer_q
# #         ).exclude(
# #             component_q
# #         ).values('component', 'manufacturer')

# #         return Response(list(filtered_data), status=status.HTTP_200_OK)

# # class ComponentWithoutSupplierView(APIView):
# #     def get(self, request):
# #         # Define skip values for Supplier and component
# #         invalid_supplier = ['dpi', 'dnp', 'snp', '-', '#N/A']
# #         invalid_components = ['cna', '-', '#N/A','N/A', 'n/a', 'dnp','dni1','dni2','dni3','Do Not Stuff','-DNI','none','no load','[noparam]','none','no load','[noparam]','Consigned','NP','Generic','DO NOT PLACE','DO NOT POPULATE','NO POP 1','NO POP']

# #  # Build case-insensitive OR filter for invalid supplier
# #         supplier_q = Q()
# #         for name in invalid_supplier:
# #             supplier_q |= Q(supplier__iexact=name)

# #         # Build exclusion Q for components (case-insensitive)
# #         component_q = Q()
# #         for cname in invalid_components:
# #             component_q |= Q(component__iexact=cname)

# #         # Filter RawData with case-insensitive matching for invalid supplier and excluding invalid components
# #         filtered_data = RawData.objects.filter(
# #             supplier_q
# #         ).exclude(
# #             component_q
# #         ).values('component', 'supplier')

# #         return Response(list(filtered_data), status=status.HTTP_200_OK)

# # class BomDataRawByOrderView(APIView):
# #     def get(self, request, order_id):
# #         try:
# #             order = OrderDetails.objects.get(order_id=order_id)
# #         except OrderDetails.DoesNotExist:
# #             return Response({"error": "Order not found"}, status=404)

# #         queryset = BomDataRaw.objects.filter(order=order)
# #         serializer = BomDataRawSerializer(queryset, many=True)

# #         return Response({
# #             "data": serializer.data,
# #             "currency": "USD"  # Changed from INR to USD
# #         }, status=200)

# # from rest_framework.views import APIView
# # from rest_framework.response import Response
# # from rest_framework import status
# # from .models import OrderDetails, BomDataRaw
# # from .serializers import BomDataRawSerializer, BomDataRawSerializer
# # from .service import paginate_queryset

# # class OrderSearchAPIView(APIView):
# #     def post(self, request):
# #         order_id = request.data.get('order_id')
# #         if not order_id:
# #             return Response({'error': 'order_id is required'}, status=status.HTTP_400_BAD_REQUEST)

# #         bom_qs = BomDataRaw.objects.filter(order_id=order_id)
# #         order_details = OrderDetails.objects.filter(order_id=order_id).first()

# #         if not bom_qs.exists():
# #             return Response({'message': f'No BOM data found for Order ID: {order_id}'}, status=404)

# #         page = request.GET.get('page', 1)
# #         paginated = paginate_queryset(bom_qs, page)

# #         return Response({
# #             'bom_data': BomDataRawSerializer(paginated, many=True).data,
# #             'order_details': BomDataRawSerializer(order_details).data if order_details else None,
# #             'currency': 'USD'  # Changed from INR to USD
# #         })

# # class ComponentSearchAPIView(APIView):
# #     def post(self, request):
# #         part_number = request.data.get('part_number', '').strip()
# #         if not part_number:
# #             return Response({'error': 'part_number is required'}, status=400)

# #         result, source = fetch_or_cache_component_data(request, part_number)
        
# #         # Update currency in result if present
# #         if isinstance(result, dict) and 'price_breaks' in result:
# #             for price_break in result['price_breaks']:
# #                 if 'currency' in price_break:
# #                     price_break['currency'] = 'USD'  # Changed from INR to USD
# #                 if 'price' in price_break:
# #                     # Format price with $ symbol instead of Rs
# #                     price_break['formatted_price'] = f"${price_break['price']:.2f}"

# #         return Response({
# #             'component': result,
# #             'source': source,
# #             'currency': 'USD'  # Changed from INR to USD
# #         })

# # class UploadedOrderSummaryAPIView(APIView):
# #     def get(self, request):
# #         order_id = request.query_params.get('uploaded_order_id')
# #         if not order_id:
# #             return Response({'error': 'uploaded_order_id is required'}, status=400)

# #         try:
# #             all_results, order_details = get_bom_data_by_order(order_id)
# #             if not all_results.exists():
# #                 return Response({'message': 'No data found'}, status=404)

# #             summary = calculate_bom_summary(all_results)
            
# #             # Update currency in summary
# #             if 'total_cost' in summary:
# #                 summary['formatted_total_cost'] = f"${summary['total_cost']:.2f}"  # Using $ instead of Rs
            
# #             return Response({
# #                 'order_id': order_id,
# #                 'summary': summary,
# #                 'order_details': BomDataRawSerializer(order_details).data,
# #                 'currency': 'USD'  # Changed from INR to USD
# #             })

# #         except Exception as e:
# #             return Response({'error': str(e)}, status=500)

# # class OrderListAPIView(APIView):
# #     def get(self, request):
# #         filter_order_id = request.query_params.get('filter_order_id')
# #         from_date = request.query_params.get('from_date')
# #         to_date = request.query_params.get('to_date')

# #         queryset = get_filtered_orders(filter_order_id, from_date, to_date)
# #         page = request.query_params.get('page', 1)
# #         paginated = paginate_queryset(queryset, page, 10)

# #         return Response({
# #             'orders': BomDataRawSerializer(paginated, many=True).data,
# #             'currency': 'USD'  # Changed from INR to USD
# #         })

# # def signup_view(request):
# #     if request.method == 'POST':
# #         form = SignUpForm(request.POST)
# #         if form.is_valid():
# #             # Save the user data
# #             user = form.save(commit=False)
# #             user.set_password(form.cleaned_data['password'])  # Set the password hash
# #             user.save()  # Save the user to the database
# #             # Add a success message
# #             messages.success(request, 'Account created successfully!')
# #             return redirect('login')  # Redirect to login page after successful signup
# #     else:
# #         form = SignUpForm()

# #     return render(request, 'accounts/signup.html', {'form': form})

# # def login_view(request):
# #     if request.method == 'POST':
# #         username = request.POST['username']
# #         password = request.POST['password'] 

# #         # Authenticate user
# #         user = authenticate(request, username=username, password=password)
# #         if user is not None:
# #             # Login the user
# #             login(request, user)
# #             messages.success(request, "Login successful!")
# #             # Redirect to the file upload page after login
# #             return redirect('uploadf')  # 'uploadfile' should be the name of your file upload URL pattern
# #         else:
# #             messages.error(request, "Invalid credentials")
# #             # Return the login form with error message
# #             return render(request, 'accounts/login.html', {'error': 'Invalid credentials'}) 

# #     # Handle GET request or initial load of the login page
# #     return render(request, 'accounts/login.html')

# # def logout_view(request):
# #     logout(request)
# #     return redirect('login')

# # def upload_view(request):
# #     if request.method == 'POST':
# #         # Handle file upload logic
# #         form = UploadFileForm(request.POST, request.FILES)
# #         if form.is_valid():
# #             # Process the file
# #             return redirect('success')  # Redirect after successful upload
# #     else:
# #         # Handle GET request to display the form
# #         form = UploadFileForm()

# #     return render(request, 'uploadf.html', {'form': form})

# # from urllib.parse import urlencode

# # def build_query_params(request, exclude_params=None):
# #     """Helper function to build query parameters for pagination"""
# #     if exclude_params is None:
# #         exclude_params = []    
# #     params = {}
# #     for key, value in request.GET.items():
# #         if key not in exclude_params and value:
# #             params[key] = value   
# #     return urlencode(params)

# # def upload_file(request):
# #     search_results = None
# #     processed_data = None
# #     order_id = None
# #     order_details = None
# #     unique_components_count = 0
# #     part_not_found = 0
# #     do_not_populate = 0
# #     part_consigned = 0
# #     form = UploadFileForm()
# #     order_search_form = OrderSearchForm()
# #     component_search_results = None
# #     component_search_source = None
# #     uploaded_order_id = request.session.get('uploaded_order_id')

# #     excluded_keys = [
# #         "Manufacturer", "ManufacturerPartNumber", "MouserPartNumber", "Category",
# #         "Min", "Availability", "FactoryStock", "LeadTime", "AvailabilityInStock",
# #         "PriceBreaks", "ProductAttributes", "DataSheetUrl", "ProductDetailUrl",
# #         "AlternatePackagings", "ProductCompliance", "Description", "ROHSStatus", "ImagePath"
# #     ]

# #     if request.method == 'POST':
# #         if 'file_upload' in request.POST:
# #             form = UploadFileForm(request.POST, request.FILES)
# #             if not request.FILES.get('file'):
# #                 messages.error(request, "No file selected.")
# #                 return redirect('uploadf')

# #             if form.is_valid():
# #                 uploaded_file = form.cleaned_data['file']
# #                 ext = os.path.splitext(uploaded_file.name)[1].lower()
# #                 if ext not in ['.xls', '.xlsx', '.csv']:
# #                     messages.error(request, "Invalid file type.")
# #                     return redirect('uploadf')

# #                 try:
# #                     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
# #                         for chunk in uploaded_file.chunks():
# #                             tmp.write(chunk)
# #                         tmp_path = tmp.name

# #                     processed_data = parse_excel_file(tmp_path, request, original_filename=uploaded_file.name)
# #                     order_id = processed_data.get('order_id')
# #                     save_parsed_data(processed_data, tmp_path)

# #                     request.session['uploaded_order_id'] = order_id
# #                     request.session['show_upload_summary'] = True

# #                     os.remove(tmp_path)
# #                     messages.success(request, f"File processed. Order ID: {order_id}")
# #                     return redirect(f'/uploadf/?show_upload_form=1&uploaded_order_id={order_id}')

# #                 except Exception as e:
# #                     if 'tmp_path' in locals() and os.path.exists(tmp_path):
# #                         os.remove(tmp_path)
# #                     messages.error(request, f"Processing error: {str(e)}")
# #                     return redirect('uploadf')

# #         elif 'order_search' in request.POST:
# #             order_search_form = OrderSearchForm(request.POST)
# #             if order_search_form.is_valid():
# #                 order_id = order_search_form.cleaned_data.get('order_id')
# #                 all_results = BomDataRaw.objects.filter(order_id=order_id)
# #                 page = request.GET.get('page', 1)
# #                 search_results = paginate_queryset(all_results, page)
# #                 order_details = OrderDetails.objects.filter(order_id=order_id).first()

# #                 if not all_results.exists():
# #                     messages.warning(request, f"No BOM data found for Order ID: {order_id}")

# #         elif 'component_search_submit' in request.POST:
# #             part_number = request.POST.get('component_search', '').strip()
# #             component_search_results, component_search_source = fetch_or_cache_component_data(request, part_number)
            
# #             # Update currency in component search results
# #             if isinstance(component_search_results, dict) and 'price_breaks' in component_search_results:
# #                 for price_break in component_search_results['price_breaks']:
# #                     if 'currency' in price_break:
# #                         price_break['currency'] = 'USD'  # Changed from INR to USD
# #                     if 'price' in price_break:
# #                         # Format price with $ symbol instead of Rs
# #                         price_break['formatted_price'] = f"${price_break['price']:.2f}"

# #     uploaded_order_id_param = request.GET.get('uploaded_order_id')
# #     if uploaded_order_id_param or (request.GET.get('show_upload_form') and uploaded_order_id):
# #         display_order_id = uploaded_order_id_param or uploaded_order_id
# #         if display_order_id:
# #             try:
# #                 all_results, order_details = get_bom_data_by_order(display_order_id)
# #                 if all_results.exists():
# #                     page = request.GET.get('page', 1)
# #                     search_results = paginate_queryset(all_results, page)
# #                     summary = calculate_bom_summary(all_results)
# #                     unique_components_count = summary["unique_components_count"]
# #                     part_not_found = summary["part_not_found"]
# #                     do_not_populate = summary["do_not_populate"]
# #                     part_consigned = summary["part_consigned"]
# #                     order_id = display_order_id

# #             except Exception as e:
# #                 messages.error(request, f"Error loading uploaded data: {str(e)}")

# #     # Filters
# #     filter_order_id = request.GET.get('filter_order_id')
# #     from_date = request.GET.get('from_date')
# #     to_date = request.GET.get('to_date')

# #     all_orders_query = get_filtered_orders(filter_order_id, from_date, to_date)
# #     orders_page = request.GET.get('orders_page', 1)
# #     all_orders = paginate_queryset(all_orders_query, orders_page, 10)

# #     # BOM Data tab
# #     selected_order_id = request.GET.get('order_id')
# #     bom_data = None
# #     if selected_order_id:
# #         try:
# #             order = OrderDetails.objects.get(order_id=selected_order_id)
# #             all_bom_data = BomDataRaw.objects.filter(order=order)
# #             bom_page = request.GET.get('bom_page', 1)
# #             bom_data = paginate_queryset(all_bom_data, bom_page, 20)
# #         except OrderDetails.DoesNotExist:
# #             bom_data = []

# #     # Query params
# #     component_search_query = request.GET.get('component_search', '').strip()
# #     search_query_params = build_query_params(request, exclude_params=['page'])
# #     orders_query_params = build_query_params(request, exclude_params=['orders_page'])
# #     bom_query_params = build_query_params(request, exclude_params=['bom_page'])

# #     return render(request, 'uploadf.html', {
# #         'form': form,
# #         'order_search_form': order_search_form,
# #         'processed_data': processed_data,
# #         'search_results': search_results,
# #         'order_details': order_details,
# #         'all_orders': all_orders,
# #         'bom_data': bom_data,
# #         'selected_order_id': selected_order_id,
# #         'unique_components_count': unique_components_count,
# #         'part_not_found': part_not_found,
# #         'do_not_populate': do_not_populate,
# #         'part_consigned': part_consigned,
# #         'filter_order_id': filter_order_id,
# #         'from_date': from_date,
# #         'to_date': to_date,
# #         'component_search_results': component_search_results,
# #         'component_search_query': component_search_query,
# #         'component_search_source': component_search_source,
# #         'search_query_params': search_query_params,
# #         'orders_query_params': orders_query_params,
# #         'bom_query_params': bom_query_params,
# #         'excluded_keys': excluded_keys,
# #         'uploaded_order_id': uploaded_order_id_param or uploaded_order_id,
# #         'currency': 'USD',  # Changed from INR to USD
# #         'currency_symbol': '$'  # Added $ symbol
# #     })

# # def parse_data_field(results):
# #     for r in results:
# #         if isinstance(r.get('data'), str):
# #             try:
# #                 r['data'] = json.loads(r['data'])
# #             except json.JSONDecodeError:
# #                 r['data'] = {}
# #     return results

# # def component_detail_view(request, component_name):
# #     parsed_results = []

# #     # ðŸ”¹ Handle external fetch when "Get Data" button is submitted
# #     if request.method == 'POST' and request.POST.get('force_external') == '1':
# #         part_number = request.POST.get('manufacturer_part_number')

# #         # Fetch from Mouser/OEMSecrets
# #         result = search_component_by_part_number(part_number)

# #         if 'error' in result:
# #             messages.error(request, result['error'])
# #             context = {
# #                 'component_search_query': component_name,
# #                 'component_search_results': None,
# #                 'component_search_source': 'None',
# #                 'show_get_data_button': True,
# #                 'currency': 'USD',  # Changed from INR to USD
# #                 'currency_symbol': '$'  # Added $ symbol
# #             }
# #             return render(request, 'componentdetails.html', context)
# #         else:
# #             # Update currency in result
# #             if 'price_breaks' in result.get('data', {}):
# #                 for price_break in result['data']['price_breaks']:
# #                     if 'currency' in price_break:
# #                         price_break['currency'] = 'USD'  # Changed from INR to USD
# #                     if 'price' in price_break:
# #                         # Format price with $ symbol instead of Rs
# #                         price_break['formatted_price'] = f"${price_break['price']:.2f}"

# #             # Simulate a DB object for rendering
# #             part = PartSearchData(
# #                 manufacturer_part_number=part_number,
# #                 data=result['data'],
# #                 source=result['source']
# #             )
# #             part.parsed_data = result['data']
# #             parsed_results.append(part)

# #             messages.success(request, f"Data fetched from {result['source']}.")
# #             context = {
# #                 'component_search_query': component_name,
# #                 'component_search_results': parsed_results,
# #                 'component_search_source': result['source'],
# #                 'show_get_data_button': False,
# #                 'currency': 'USD',  # Changed from INR to USD
# #                 'currency_symbol': '$'  # Added $ symbol
# #             }
# #             return render(request, 'componentdetails.html', context)

# #     # ðŸ”¹ Handle normal GET â€” check in DB
# #     results = PartSearchData.objects.filter(manufacturer_part_number__iexact=component_name)

# #     if results.exists():
# #         for part in results:
# #             try:
# #                 # Parse JSON data
# #                 if part.data:
# #                     parsed_data = json.loads(part.data) if isinstance(part.data, str) else part.data
                    
# #                     # Update currency in parsed data
# #                     if 'price_breaks' in parsed_data:
# #                         for price_break in parsed_data['price_breaks']:
# #                             if 'currency' in price_break:
# #                                 price_break['currency'] = 'USD'  # Changed from INR to USD
# #                             if 'price' in price_break:
# #                                 # Format price with $ symbol instead of Rs
# #                                 price_break['formatted_price'] = f"${price_break['price']:.2f}"
                    
# #                     part.parsed_data = parsed_data
# #                 else:
# #                     part.parsed_data = {}

# #             except (json.JSONDecodeError, ValidationError) as e:
# #                 part.parsed_data = {}
# #                 part.json_error = str(e)

# #             parsed_results.append(part)

# #     context = {
# #         'component_search_query': component_name,
# #         'component_search_results': parsed_results if parsed_results else None,
# #         'component_search_source': 'Database' if parsed_results else 'None',
# #         'show_get_data_button': not parsed_results,
# #         'currency': 'USD',  # Changed from INR to USD
# #         'currency_symbol': '$'  # Added $ symbol
# #     }

# #     return render(request, 'componentdetails.html', context)

# # def handle_uploaded_file(uploaded_file):
# #     # Get file extension from the uploaded file name
# #     ext = os.path.splitext(uploaded_file.name)[1]

# #     # Save uploaded file to a temporary file
# #     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
# #         for chunk in uploaded_file.chunks():  # Write in chunks for large files
# #             tmp.write(chunk)
# #         tmp_path = tmp.name  # This is the file path to pass

# #     return tmp_path

# # # refer/api/views.py
# # def component_search_view(request):
# #     result = None
# #     not_found = False

# #     if request.method == 'POST':
# #         form = ComponentSearchForm(request.POST)
# #         if form.is_valid():
# #             part_number = form.cleaned_data['manufacturer_part_number']
# #             currency = 'USD'  # Changed from form.cleaned_data.get('currency') or 'USD'
# #             country_code = form.cleaned_data.get('country_code') or 'AT'

# #             result = search_component_by_part_number(part_number, currency, country_code)
            
# #             # Update currency in result
# #             if result and 'price_breaks' in result:
# #                 for price_break in result['price_breaks']:
# #                     if 'currency' in price_break:
# #                         price_break['currency'] = 'USD'  # Changed from INR to USD
# #                     if 'price' in price_break:
# #                         # Format price with $ symbol instead of Rs
# #                         price_break['formatted_price'] = f"${price_break['price']:.2f}"
            
# #             if 'error' in result:
# #                 not_found = True
# #     else:
# #         form = ComponentSearchForm()

# #     return render(request, 'component_search.html', {
# #         'form': form,
# #         'result': result,
# #         'not_found': not_found,
# #         'currency': 'USD',  # Changed from INR to USD
# #         'currency_symbol': '$'  # Added $ symbol
# #     })

# # logger = logging.getLogger(__name__)

# # from django.http import JsonResponse, HttpResponse
# # from django.db.models import Q
# # from django.core.paginator import Paginator
# # from .models import ComponentCrons, ComponentPrice
# # from datetime import datetime, timedelta, date
# # import json
# # import matplotlib
# # matplotlib.use('Agg')  # Use non-interactive backend
# # import matplotlib.pyplot as plt
# # import matplotlib.dates as mdates
# # from matplotlib.figure import Figure
# # import io
# # import base64
# # import pandas as pd
# # import numpy as np
# # from collections import defaultdict
# # import logging

# # logger = logging.getLogger(__name__)

# # def component_list(request):
# #     """View to display all components with search functionality"""
# #     search_query = request.GET.get('search', '')
# #     page_number = request.GET.get('page', 1)
    
# #     # Get unique components from ComponentCrons
# #     components = ComponentCrons.objects.values('component_name').distinct()
    
# #     if search_query:
# #         components = components.filter(component_name__icontains=search_query)
    
# #     # Get additional details for each component
# #     component_list = []
# #     for comp in components:
# #         component_name = comp['component_name']
# #         latest_entry = ComponentCrons.objects.filter(
# #             component_name=component_name
# #         ).order_by('-fetched_at').first()
        
# #         # Get latest price
# #         latest_price = ComponentPrice.objects.filter(
# #             part_number=component_name
# #         ).order_by('-date', 'quantity').first()
        
# #         component_list.append({
# #             'name': component_name,
# #             'source': latest_entry.source if latest_entry else 'Unknown',
# #             'last_updated': latest_entry.fetched_at if latest_entry else None,
# #             'latest_price': latest_price.price if latest_price else None,
# #             'currency': 'USD',  # Changed from latest_price.currency to USD
# #             'formatted_price': f"${latest_price.price:.2f}" if latest_price else None,  # Using $ instead of Rs
# #             'data_points': ComponentPrice.objects.filter(part_number=component_name).count()
# #         })
        
# #     # Paginate results
# #     paginator = Paginator(component_list, 20)  # Show 20 components per page
# #     page_obj = paginator.get_page(page_number)
    
# #     context = {
# #         'components': page_obj,
# #         'search_query': search_query,
# #         'total_components': len(component_list),
# #         'currency': 'USD',  # Changed from INR to USD
# #         'currency_symbol': '$'  # Added $ symbol
# #     }
    
# #     return render(request, 'component_list.html', context)

# # def generate_price_graphs(component_name, days=30):
# #     """Generate matplotlib graphs for component price data with all quantities on one chart"""
# #     try:
# #         # Calculate the exact start date
# #         today = date.today()
# #         start_date = today - timedelta(days=days)
        
# #         logger.info(f"Generating graphs for {component_name}")
# #         logger.info(f"Date range: {start_date} to {today} ({days} days)")
        
# #         # Filter price data with exact date range
# #         price_data = ComponentPrice.objects.filter(
# #             part_number=component_name,
# #             date__gte=start_date,
# #             date__lte=today
# #         ).order_by('date', 'quantity')
        
# #         logger.info(f"Found {price_data.count()} price records")
        
# #         if not price_data.exists():
# #             logger.warning(f"No price data found for {component_name} in date range {start_date} to {today}")
# #             return None, None, []
        
# #         # Debug: Print actual date range of data
# #         actual_dates = price_data.values_list('date', flat=True).distinct().order_by('date')
# #         if actual_dates:
# #             logger.info(f"Actual data dates: {list(actual_dates)[:5]}...{list(actual_dates)[-5:]}")
        
# #         # Group data by quantity
# #         quantity_data = defaultdict(list)
# #         for price in price_data:
# #             quantity_data[price.quantity].append({
# #                 'date': price.date,
# #                 'price': float(price.price),
# #                 'currency': 'USD'  # Changed from price.currency to USD
# #             })
        
# #         # Sort quantities for consistent ordering
# #         sorted_quantities = sorted(quantity_data.keys())
# #         currency = 'USD'  # Changed from price_data.first().currency to USD
        
# #         if len(sorted_quantities) == 0:
# #             return None, None, []
        
# #         logger.info(f"Processing {len(sorted_quantities)} different quantities: {sorted_quantities}")
        
# #         # Set matplotlib style for better appearance
# #         plt.style.use('default')
# #         plt.rcParams.update({
# #             'figure.facecolor': 'white',
# #             'axes.facecolor': 'white',
# #             'font.size': 12,
# #             'axes.titlesize': 16,
# #             'axes.labelsize': 14,
# #             'xtick.labelsize': 12,
# #             'ytick.labelsize': 12,
# #             'legend.fontsize': 11
# #         })
        
# #         # Create single figure for all quantities
# #         fig, ax = plt.subplots(figsize=(16, 10))
        
# #         # Modern color palette - more colors for different quantities
# #         colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
# #                   '#06B6D4', '#84CC16', '#F97316', '#EC4899', '#6366F1',
# #                   '#14B8A6', '#F472B6', '#A855F7', '#22D3EE', '#FDE047']
        
# #         # Plot each quantity as a separate line
# #         graphs_data = []
        
# #         for idx, quantity in enumerate(sorted_quantities):
# #             data = quantity_data[quantity]
# #             dates = [item['date'] for item in data]
# #             prices = [item['price'] for item in data]
            
# #             logger.info(f"Quantity {quantity}: {len(dates)} data points from {min(dates) if dates else 'N/A'} to {max(dates) if dates else 'N/A'}")
            
# #             # Plot the line for this quantity
# #             color = colors[idx % len(colors)]
# #             ax.plot(dates, prices, 
# #                    marker='o', 
# #                    linewidth=3, 
# #                    markersize=6, 
# #                    color=color, 
# #                    label=f'{quantity:,} pcs',
# #                    markerfacecolor='white', 
# #                    markeredgewidth=2, 
# #                    markeredgecolor=color,
# #                    alpha=0.8)
            
# #             # Store graph data for summary
# #             if len(prices) > 0:
# #                 graphs_data.append({
# #                     'quantity': quantity,
# #                     'min_price': min(prices),
# #                     'max_price': max(prices),
# #                     'avg_price': sum(prices) / len(prices),
# #                     'data_points': len(prices),
# #                     'currency': currency,
# #                     'formatted_min_price': f"${min(prices):.2f}",  # Using $ instead of Rs
# #                     'formatted_max_price': f"${max(prices):.2f}",  # Using $ instead of Rs
# #                     'formatted_avg_price': f"${sum(prices) / len(prices):.2f}",  # Using $ instead of Rs
# #                     'date_range': f"{min(dates).strftime('%m/%d')} - {max(dates).strftime('%m/%d')}"
# #                 })
        
# #         # Customize the main chart
# #         title = f'Price Trends for {component_name}\n({start_date.strftime("%b %d, %Y")} to {today.strftime("%b %d, %Y")} - {days} days)'
# #         ax.set_title(title, fontsize=18, fontweight='bold', pad=30)
# #         ax.set_xlabel('Date', fontsize=14, fontweight='500')
# #         ax.set_ylabel(f'Price (USD)', fontsize=14, fontweight='500')  # Changed from ({currency}) to (USD)
# #         ax.grid(True, alpha=0.3, linestyle='--')
# #         ax.set_facecolor('#FAFAFA')
        
# #         # Format x-axis dates based on the time period
# #         if len(actual_dates) > 0:
# #             # Use actual dates for x-axis positioning to reduce gaps
# #             ax.set_xlim(min(actual_dates), max(actual_dates))
            
# #             if days <= 7:
# #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# #                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
# #             elif days <= 30:
# #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# #                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(actual_dates)//8)))
# #             elif days <= 90:
# #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
# #                 ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=max(1, len(actual_dates)//10)))
# #             else:
# #                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%y'))
# #                 ax.xaxis.set_major_locator(mdates.MonthLocator(interval=max(1, len(actual_dates)//8)))
            
# #             plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
# #         # Reduce margins for tighter layout
# #         ax.margins(x=0.01, y=0.05)  # Reduced x-margin from 0.02 to 0.01
        
# #         # Add legend with better positioning
# #         legend = ax.legend(loc='upper left', 
# #                           bbox_to_anchor=(0.02, 0.98),
# #                           frameon=True, 
# #                           fancybox=True, 
# #                           shadow=True,
# #                           ncol=min(3, len(sorted_quantities)),  # Max 3 columns
# #                           fontsize=11)
# #         legend.get_frame().set_facecolor('white')
# #         legend.get_frame().set_alpha(0.9)
        
# #         # Style the axes
# #         ax.spines['top'].set_visible(False)
# #         ax.spines['right'].set_visible(False)
# #         ax.spines['left'].set_color('#E5E7EB')
# #         ax.spines['bottom'].set_color('#E5E7EB')
        
# #         # Add some padding to the plot
        
        
# #         plt.tight_layout()
# #         plt.subplots_adjust(top=0.85, bottom=0.15, left=0.08, right=0.95)  # Tighter layout
        
# #         # Convert plot to base64 string
# #         buffer = io.BytesIO()
# #         plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight', 
# #                     facecolor='white', edgecolor='none', pad_inches=0.3)
# #         buffer.seek(0)
# #         image_base64 = base64.b64encode(buffer.getvalue()).decode()
# #         plt.close()
        
# #         # Create summary statistics graph (bar chart)
# #         summary_image_base64 = None
# #         if len(graphs_data) > 1:  # Only create summary if multiple quantities
# #             try:
# #                 summary_fig, summary_ax = plt.subplots(figsize=(14, 8))
# #                 summary_fig.patch.set_facecolor('white')
                
# #                 # Prepare data for summary graph
# #                 quantities_list = [data['quantity'] for data in graphs_data]
# #                 avg_prices = [data['avg_price'] for data in graphs_data]
# #                 min_prices = [data['min_price'] for data in graphs_data]
# #                 max_prices = [data['max_price'] for data in graphs_data]
                
# #                 x = np.arange(len(quantities_list))
# #                 width = 0.25
                
# #                 # Create grouped bar chart with modern styling
# #                 bars1 = summary_ax.bar(x - width, min_prices, width, label='Min Price', 
# #                                       color='#10B981', alpha=0.8, edgecolor='white', linewidth=2)
# #                 bars2 = summary_ax.bar(x, avg_prices, width, label='Avg Price', 
# #                                       color='#3B82F6', alpha=0.8, edgecolor='white', linewidth=2)
# #                 bars3 = summary_ax.bar(x + width, max_prices, width, label='Max Price', 
# #                                       color='#EF4444', alpha=0.8, edgecolor='white', linewidth=2)
                
# #                 summary_ax.set_xlabel('Quantity (pieces)', fontsize=12, fontweight='500')
# #                 summary_ax.set_ylabel(f'Price (USD)', fontsize=12, fontweight='500')  # Changed from ({currency}) to (USD)
# #                 summary_ax.set_title(f'Price Summary for {component_name}\n({start_date.strftime("%b %d")} - {today.strftime("%b %d, %Y")})', 
# #                                     fontsize=16, fontweight='bold', pad=20)
# #                 summary_ax.set_xticks(x)
# #                 summary_ax.set_xticklabels([f'{q:,}' for q in quantities_list])
# #                 summary_ax.legend(frameon=False, loc='upper left')
# #                 summary_ax.grid(True, alpha=0.3, axis='y', linestyle='--')
# #                 summary_ax.set_facecolor('#FAFAFA')
                
# #                 # Style the axes
# #                 summary_ax.spines['top'].set_visible(False)
# #                 summary_ax.spines['right'].set_visible(False)
# #                 summary_ax.spines['left'].set_color('#E5E7EB')
# #                 summary_ax.spines['bottom'].set_color('#E5E7EB')
                
# #                 # Add value labels on bars with $ symbol
# #                 def add_value_labels(bars, values):
# #                     for bar, value in zip(bars, values):
# #                         height = bar.get_height()
# #                         summary_ax.text(bar.get_x() + bar.get_width()/2., height + max(max_prices) * 0.02,
# #                                        f'${value:.2f}', ha='center', va='bottom', fontsize=10, fontweight='bold')  # Using $ instead of Rs
                
# #                 add_value_labels(bars1, min_prices)
# #                 add_value_labels(bars2, avg_prices)
# #                 add_value_labels(bars3, max_prices)
                
# #                 plt.tight_layout()
                
# #                 # Convert summary plot to base64 string
# #                 summary_buffer = io.BytesIO()
# #                 plt.savefig(summary_buffer, format='png', dpi=200, bbox_inches='tight',
# #                            facecolor='white', edgecolor='none', pad_inches=0.2)
# #                 summary_buffer.seek(0)
# #                 summary_image_base64 = base64.b64encode(summary_buffer.getvalue()).decode()
# #                 plt.close()
# #             except Exception as e:
# #                 logger.error(f"Error creating summary graph: {e}")
# #                 summary_image_base64 = None
        
# #         logger.info(f"Successfully generated graphs for {component_name} with {len(graphs_data)} quantities")
# #         return image_base64, summary_image_base64, graphs_data
        
# #     except Exception as e:
# #         logger.error(f"Error generating graphs for {component_name}: {e}")
# #         return None, None, []

# # def component_price_graph(request, component_name):
# #     """View to display price graph for a specific component"""
# #     try:
# #         component = ComponentCrons.objects.filter(component_name=component_name).first()
# #     except Exception as e:
# #         logger.error(f"Error fetching component {component_name}: {e}")
# #         component = None
    
# #     # Get the number of days from request - default to 30
# #     days = int(request.GET.get('days', 30))
# #     logger.info(f"Loading component_price_graph for {component_name}, days: {days}")
    
# #     # Generate graphs
# #     price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
    
# #     # Get component details
# #     latest_entry = ComponentCrons.objects.filter(
# #         component_name=component_name
# #     ).order_by('-fetched_at').first()
    
# #     # Get currency info
# #     latest_price = ComponentPrice.objects.filter(
# #         part_number=component_name
# #     ).order_by('-date').first()
    
# #     context = {
# #         'component_name': component_name,
# #         'component': latest_entry,
# #         'price_graph': price_graph,
# #         'summary_graph': summary_graph,
# #         'graphs_data': graphs_data,
# #         'currency': 'USD',  # Changed from latest_price.currency to USD
# #         'currency_symbol': '$',  # Added $ symbol
# #         'selected_days': days,
# #         'has_data': price_graph is not None
# #     }
    
# #     logger.info(f"Context: has_data={context['has_data']}, selected_days={context['selected_days']}")
# #     return render(request, 'component_price_graph.html', context)

# # def component_price_api(request, component_name):
# #     """API endpoint to get price data for AJAX requests"""
# #     days = int(request.GET.get('days', 30))
# #     logger.info(f"API call for {component_name}, days: {days}")
    
# #     try:
# #         # Generate new graphs with the requested time period
# #         price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
        
# #         response_data = {
# #             'price_graph': price_graph,
# #             'summary_graph': summary_graph,
# #             'graphs_data': graphs_data,
# #             'has_data': price_graph is not None,
# #             'currency': 'USD',  # Changed from graphs_data[0]['currency'] to USD
# #             'currency_symbol': '$',  # Added $ symbol
# #             'days': days  # Include the actual days processed
# #         }
        
# #         logger.info(f"API response: has_data={response_data['has_data']}, days={days}")
# #         return JsonResponse(response_data)
        
# #     except Exception as e:
# #         logger.error(f"API error for {component_name}: {e}")
# #         return JsonResponse({
# #             'error': str(e),
# #             'has_data': False,
# #             'price_graph': None,
# #             'summary_graph': None,
# #             'graphs_data': [],
# #             'currency': 'USD',  # Changed from INR to USD
# #             'currency_symbol': '$',  # Added $ symbol
# #             'days': days
# #         }, status=500)


# from django.shortcuts import render, redirect
# from django.contrib.auth import authenticate, login, logout
# from rest_framework import generics
# from django.db.models import Q, Prefetch
# from rest_framework.views import APIView
# from rest_framework.response import Response
# from rest_framework.parsers import MultiPartParser, FormParser
# from rest_framework import status
# from django.core.cache import cache
# from django.db import transaction
# from django.utils.decorators import method_decorator
# from django.views.decorators.cache import cache_page
# from django.views.decorators.vary import vary_on_headers
# import logging
# import warnings
# from collections import defaultdict
# from django.http import HttpResponse, JsonResponse
# from django.contrib import messages
# from django.core.paginator import Paginator
# from urllib.parse import urlencode
# import os
# import tempfile
# import json
# from django.core.exceptions import ValidationError
# from datetime import datetime, timedelta, date
# import matplotlib
# matplotlib.use('Agg')
# import matplotlib.pyplot as plt
# import matplotlib.dates as mdates
# import io
# import base64
# import pandas as pd
# import numpy as np

# # Import your models and serializers
# from .models import (
#     Excelfile, OrderDetails, Manufacturers, Components, Suppliers, BomDetails,
#     ComponentOrderData, RawData, BomDataRaw, PartSearchData, ComponentCrons, ComponentPrice
# )
# from .serializers import (
#     ExcelFileSerializer, BomDetailsSerializer, SupplierSummarySerializer,
#     ManufacturerSerializer, ComponentOrderDataSerializer, SupplierSerializer,
#     RawDataSerializer, BomDataRawSerializer
# )
# from .forms import UploadFileForm, OrderSearchForm, SignUpForm, ComponentSearchForm
# from .service import (
#     paginate_queryset, calculate_bom_summary, get_bom_data_by_order,
#     get_filtered_orders, search_component_by_part_number, search_mouser_component,
#     fetch_from_oem_secrets, fetch_or_cache_component_data
# )
# from .process_excel_file import process_excel_file, parse_excel_file, save_parsed_data

# # Configure logging and warnings
# warnings.simplefilter(action='ignore', category=FutureWarning)
# logger = logging.getLogger(__name__)

# # Constants
# INVALID_MANUFACTURERS = ['mpi', 'dpi', 'dnp', 'mnp', '-', '#N/A', 'Consigned']
# INVALID_SUPPLIERS = ['dpi', 'dnp', 'snp', '-', '#N/A']
# INVALID_COMPONENTS = [
#     'cna', '-', '#N/A', 'N/A', 'n/a', 'dnp', 'dni1', 'dni2', 'dni3',
#     'Do Not Stuff', '-DNI', 'none', 'no load', '[noparam]', 'Consigned',
#     'NP', 'Generic', 'DO NOT PLACE', 'DO NOT POPULATE', 'NO POP 1', 'NO POP'
# ]
# SKIP_VALUES = [
#     'DNI', 'DNP', 'MNP', 'CNA', 'SCNA', 'SNP', '-', '#N/A', 'DNI 1', 'DNI 2',
#     'DNI 3', 'Do Not Stuff', '-DNI', 'none', 'no load', '[noparam]',
#     'Consigned', 'NP', 'Generic', 'DO NOT PLACE', 'DO NOT POPULATE', 'NO POP 1', 'NO POP'
# ]
# EXCLUDED_KEYS = [
#     "Manufacturer", "ManufacturerPartNumber", "MouserPartNumber", "Category",
#     "Min", "Availability", "FactoryStock", "LeadTime", "AvailabilityInStock",
#     "PriceBreaks", "ProductAttributes", "DataSheetUrl", "ProductDetailUrl",
#     "AlternatePackagings", "ProductCompliance", "Description", "ROHSStatus", "ImagePath"
# ]

# # Utility functions
# def build_case_insensitive_q(field_name, values):
#     """Build case-insensitive Q object for multiple values"""
#     q = Q()
#     for value in values:
#         q |= Q(**{f"{field_name}__iexact": value})
#     return q

# def format_price_usd(price):
#     """Format price with USD symbol"""
#     return f"${float(price):.2f}" if price else "$0.00"

# def get_cache_key(prefix, *args):
#     """Generate cache key"""
#     return f"{prefix}:{'_'.join(str(arg) for arg in args)}"

# # Views
# def home(request):
#     return HttpResponse("Welcome to the Excel Upload API. Use /api/upload/ to upload your Excel file.")

# class UploadExcelView(APIView):
#     parser_classes = [MultiPartParser, FormParser]

#     def post(self, request, *args, **kwargs):
#         file_serializer = ExcelFileSerializer(data=request.data)
#         if file_serializer.is_valid():
#             file_instance = file_serializer.save()
#             excel_file = file_instance.file.path
#             return process_excel_file(excel_file, request, return_json=True)
#         return Response(file_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# class BomByOrderIDView(APIView):
#     def get(self, request, order_id):
#         # Use cache for frequently accessed data
#         cache_key = get_cache_key('bom_order', order_id)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return Response(cached_data, status=status.HTTP_200_OK)

#         try:
#             order = OrderDetails.objects.get(order_id=order_id)
#         except OrderDetails.DoesNotExist:
#             return Response({"error": "Order ID not found."}, status=status.HTTP_404_NOT_FOUND)

#         # Use select_related to reduce database queries
#         bom_entries = BomDetails.objects.filter(order=order).select_related(
#             'manufacturer', 'component', 'supplier'
#         )
        
#         serializer = BomDetailsSerializer(bom_entries, many=True)

#         # Optimize data grouping using defaultdict
#         manufacturer_data = defaultdict(list)
#         supplier_data = defaultdict(list)
        
#         for entry in bom_entries:
#             manufacturer = str(entry.manufacturer or "MNP")
#             component = str(entry.component or "CNA")
#             supplier = str(entry.supplier or "SNP")
#             supplier_part_no = str(entry.supplier_component or "SCNA")
#             unit_price = float(entry.unit_price or 0)
            
#             manufacturer_data[manufacturer].append(component)
#             supplier_data[supplier].append({
#                 "supplier_part_no": supplier_part_no,
#                 "unit_price": unit_price
#             })

#         # Build summaries more efficiently
#         manufacturer_summary = [
#             {
#                 "manufacturer": manufacturer,
#                 "components": [{"component_name": comp} for comp in components]
#             }
#             for manufacturer, components in manufacturer_data.items()
#         ]

#         supplier_summary = [
#             {
#                 "supplier": supplier,
#                 "parts": parts,
#                 "total_unit_price": sum(part['unit_price'] for part in parts),
#                 "currency": "USD"
#             }
#             for supplier, parts in supplier_data.items()
#         ]

#         response_data = {
#             "bom_details": serializer.data,
#             "manufacturer_summary": manufacturer_summary,
#             "supplier_summary": SupplierSummarySerializer(supplier_summary, many=True).data,
#             "currency": "USD"
#         }
        
#         # Cache the result for 15 minutes
#         cache.set(cache_key, response_data, 900)
        
#         return Response(response_data, status=status.HTTP_200_OK)

# @method_decorator(cache_page(300), name='get')  # Cache for 5 minutes
# class ManufacturerListView(APIView):
#     def get(self, request):
#         manufacturers = Manufacturers.objects.all()
#         serializer = ManufacturerSerializer(manufacturers, many=True)
#         return Response(serializer.data, status=status.HTTP_200_OK)

# @method_decorator(cache_page(300), name='get')  # Cache for 5 minutes
# class SupplierListView(APIView):
#     def get(self, request):
#         suppliers = Suppliers.objects.all()
#         serializer = SupplierSerializer(suppliers, many=True)
#         return Response(serializer.data, status=status.HTTP_200_OK)

# class ComponentOrderIDsView(APIView):
#     def get(self, request, *args, **kwargs):
#         component_name = request.query_params.get("component_name")
#         if not component_name:
#             return Response(
#                 {"error": "component_name parameter is required."}, 
#                 status=status.HTTP_400_BAD_REQUEST
#             )

#         # Use cache for component lookups
#         cache_key = get_cache_key('component_orders', component_name)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return Response(cached_data)

#         try:
#             component = Components.objects.filter(component__iexact=component_name).first()
#             if not component:
#                 return Response(
#                     {"error": "Component not found."}, 
#                     status=status.HTTP_404_NOT_FOUND
#                 )

#             if component.component.strip().lower() in ['cna', 'na', 'n / a', '-']:
#                 return Response(
#                     {"error": "Component is not valid (N/A)."}, 
#                     status=status.HTTP_400_BAD_REQUEST
#                 )

#             # Use values_list with flat=True for better performance
#             order_ids = list(
#                 BomDetails.objects
#                 .filter(component=component)
#                 .values_list("order_id", flat=True)
#                 .distinct()
#             )

#             response_data = {
#                 "component_name": component.component,
#                 "order_ids": order_ids,
#                 "total_orders": len(order_ids)
#             }
            
#             # Cache for 10 minutes
#             cache.set(cache_key, response_data, 600)
            
#             return Response(response_data)

#         except Exception as e:
#             logger.error(f"Error in ComponentOrderIDsView: {str(e)}")
#             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

# class BulkComponentOrderIDsView(APIView):
#     @transaction.atomic
#     def post(self, request, *args, **kwargs):
#         # Use select_related to optimize query
#         components = Components.objects.exclude(
#             component__icontains='CNA'
#         ).select_related()[:100]
        
#         created_data = []
#         bulk_create_list = []

#         for component in components:
#             if component.component.strip().lower() in INVALID_COMPONENTS:
#                 continue

#             order_ids = list(
#                 BomDetails.objects
#                 .filter(component=component)
#                 .values_list("order_id", flat=True)
#                 .distinct()
#             )

#             if len(order_ids) < 2:
#                 continue

#             # Use get_or_create more efficiently
#             data, created = ComponentOrderData.objects.get_or_create(
#                 component_name=component.component,
#                 defaults={
#                     'order_ids': order_ids,
#                     'total_orders': len(order_ids)
#                 }
#             )
#             created_data.append(data)

#         serializer = ComponentOrderDataSerializer(created_data, many=True)
#         return Response({
#             "message": f"Order data stored for {len(created_data)} components (excluding unknown/CNP/low-count).",
#             "data": serializer.data
#         }, status=status.HTTP_201_CREATED)

# class RawDataListAPIView(generics.ListAPIView):
#     serializer_class = RawDataSerializer

#     def get_queryset(self):
#         queryset = RawData.objects.select_related().all()
#         order_id = self.request.query_params.get('order_id')
#         if order_id:
#             queryset = queryset.filter(order_id=order_id)
#         return queryset

#     def list(self, request, *args, **kwargs):
#         queryset = self.get_queryset()
#         serializer = self.get_serializer(queryset, many=True)

#         # Optimize counting using a single query with aggregation
#         type_counts = {}
#         for skip_value in SKIP_VALUES:
#             count = queryset.filter(
#                 Q(component__iexact=skip_value) |
#                 Q(manufacturer__iexact=skip_value) |
#                 Q(supplier_part_no__iexact=skip_value) |
#                 Q(supplier__iexact=skip_value)
#             ).count()
#             type_counts[skip_value.lower()] = count

#         return Response({
#             'order_id': request.query_params.get('order_id'),
#             'counts': type_counts,
#             'data': serializer.data,
#             'currency': 'USD'
#         }, status=status.HTTP_200_OK)

# class ComponentsWithoutValidManufacturerView(APIView):
#     def get(self, request):
#         # Use optimized Q objects
#         manufacturer_q = build_case_insensitive_q('manufacturer', INVALID_MANUFACTURERS)
#         component_q = build_case_insensitive_q('component', INVALID_COMPONENTS)

#         filtered_data = RawData.objects.filter(
#             manufacturer_q
#         ).exclude(
#             component_q
#         ).values('component', 'manufacturer')

#         return Response(list(filtered_data), status=status.HTTP_200_OK)

# class ComponentWithoutSupplierView(APIView):
#     def get(self, request):
#         # Use optimized Q objects
#         supplier_q = build_case_insensitive_q('supplier', INVALID_SUPPLIERS)
#         component_q = build_case_insensitive_q('component', INVALID_COMPONENTS)

#         filtered_data = RawData.objects.filter(
#             supplier_q
#         ).exclude(
#             component_q
#         ).values('component', 'supplier')

#         return Response(list(filtered_data), status=status.HTTP_200_OK)

# class BomDataRawByOrderView(APIView):
#     def get(self, request, order_id):
#         try:
#             order = OrderDetails.objects.get(order_id=order_id)
#         except OrderDetails.DoesNotExist:
#             return Response({"error": "Order not found"}, status=404)

#         # Use select_related for optimization
#         queryset = BomDataRaw.objects.filter(order=order).select_related()
#         serializer = BomDataRawSerializer(queryset, many=True)

#         return Response({
#             "data": serializer.data,
#             "currency": "USD"
#         }, status=200)

# class OrderSearchAPIView(APIView):
#     def post(self, request):
#         order_id = request.data.get('order_id')
#         if not order_id:
#             return Response({'error': 'order_id is required'}, status=status.HTTP_400_BAD_REQUEST)

#         # Use select_related for optimization
#         bom_qs = BomDataRaw.objects.filter(order_id=order_id).select_related()
#         order_details = OrderDetails.objects.filter(order_id=order_id).first()

#         if not bom_qs.exists():
#             return Response({'message': f'No BOM data found for Order ID: {order_id}'}, status=404)

#         page = request.GET.get('page', 1)
#         paginated = paginate_queryset(bom_qs, page)

#         return Response({
#             'bom_data': BomDataRawSerializer(paginated, many=True).data,
#             'order_details': BomDataRawSerializer(order_details).data if order_details else None,
#             'currency': 'USD'
#         })

# class ComponentSearchAPIView(APIView):
#     def post(self, request):
#         part_number = request.data.get('part_number', '').strip()
#         if not part_number:
#             return Response({'error': 'part_number is required'}, status=400)

#         # Use cache for component search results
#         cache_key = get_cache_key('component_search', part_number)
#         cached_result = cache.get(cache_key)
        
#         if cached_result:
#             return Response(cached_result)

#         result, source = fetch_or_cache_component_data(request, part_number)
        
#         # Update currency in result if present
#         if isinstance(result, dict) and 'price_breaks' in result:
#             for price_break in result['price_breaks']:
#                 if 'currency' in price_break:
#                     price_break['currency'] = 'USD'
#                 if 'price' in price_break:
#                     price_break['formatted_price'] = format_price_usd(price_break['price'])

#         response_data = {
#             'component': result,
#             'source': source,
#             'currency': 'USD'
#         }
        
#         # Cache for 5 minutes
#         cache.set(cache_key, response_data, 300)
        
#         return Response(response_data)

# class UploadedOrderSummaryAPIView(APIView):
#     def get(self, request):
#         order_id = request.query_params.get('uploaded_order_id')
#         if not order_id:
#             return Response({'error': 'uploaded_order_id is required'}, status=400)

#         # Use cache for summary data
#         cache_key = get_cache_key('order_summary', order_id)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return Response(cached_data)

#         try:
#             all_results, order_details = get_bom_data_by_order(order_id)
#             if not all_results.exists():
#                 return Response({'message': 'No data found'}, status=404)

#             summary = calculate_bom_summary(all_results)
            
#             if 'total_cost' in summary:
#                 summary['formatted_total_cost'] = format_price_usd(summary['total_cost'])
            
#             response_data = {
#                 'order_id': order_id,
#                 'summary': summary,
#                 'order_details': BomDataRawSerializer(order_details).data,
#                 'currency': 'USD'
#             }
            
#             # Cache for 10 minutes
#             cache.set(cache_key, response_data, 600)
            
#             return Response(response_data)

#         except Exception as e:
#             logger.error(f"Error in UploadedOrderSummaryAPIView: {str(e)}")
#             return Response({'error': str(e)}, status=500)

# class OrderListAPIView(APIView):
#     def get(self, request):
#         filter_order_id = request.query_params.get('filter_order_id')
#         from_date = request.query_params.get('from_date')
#         to_date = request.query_params.get('to_date')

#         # Use cache for filtered orders
#         cache_key = get_cache_key('filtered_orders', filter_order_id, from_date, to_date)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return Response(cached_data)

#         queryset = get_filtered_orders(filter_order_id, from_date, to_date)
#         page = request.query_params.get('page', 1)
#         paginated = paginate_queryset(queryset, page, 10)

#         response_data = {
#             'orders': BomDataRawSerializer(paginated, many=True).data,
#             'currency': 'USD'
#         }
        
#         # Cache for 5 minutes
#         cache.set(cache_key, response_data, 300)
        
#         return Response(response_data)

# # Authentication views (optimized)
# def signup_view(request):
#     if request.method == 'POST':
#         form = SignUpForm(request.POST)
#         if form.is_valid():
#             with transaction.atomic():
#                 user = form.save(commit=False)
#                 user.set_password(form.cleaned_data['password'])
#                 user.save()
#             messages.success(request, 'Account created successfully!')
#             return redirect('login')
#     else:
#         form = SignUpForm()

#     return render(request, 'accounts/signup.html', {'form': form})

# def login_view(request):
#     if request.method == 'POST':
#         username = request.POST['username']
#         password = request.POST['password']

#         user = authenticate(request, username=username, password=password)
#         if user is not None:
#             login(request, user)
#             messages.success(request, "Login successful!")
#             return redirect('uploadf')
#         else:
#             messages.error(request, "Invalid credentials")
#             return render(request, 'accounts/login.html', {'error': 'Invalid credentials'})

#     return render(request, 'accounts/login.html')

# def logout_view(request):
#     logout(request)
#     return redirect('login')

# def upload_view(request):
#     if request.method == 'POST':
#         form = UploadFileForm(request.POST, request.FILES)
#         if form.is_valid():
#             return redirect('success')
#     else:
#         form = UploadFileForm()

#     return render(request, 'uploadf.html', {'form': form})

# def build_query_params(request, exclude_params=None):
#     """Optimized helper function to build query parameters for pagination"""
#     if exclude_params is None:
#         exclude_params = []
    
#     return urlencode({
#         key: value for key, value in request.GET.items()
#         if key not in exclude_params and value
#     })

# def upload_file(request):
#     # Initialize variables
#     context_vars = {
#         'search_results': None,
#         'processed_data': None,
#         'order_id': None,
#         'order_details': None,
#         'unique_components_count': 0,
#         'part_not_found': 0,
#         'do_not_populate': 0,
#         'part_consigned': 0,
#         'component_search_results': None,
#         'component_search_source': None,
#     }
    
#     form = UploadFileForm()
#     order_search_form = OrderSearchForm()
#     uploaded_order_id = request.session.get('uploaded_order_id')

#     if request.method == 'POST':
#         if 'file_upload' in request.POST:
#             form = UploadFileForm(request.POST, request.FILES)
#             if not request.FILES.get('file'):
#                 messages.error(request, "No file selected.")
#                 return redirect('uploadf')

#             if form.is_valid():
#                 uploaded_file = form.cleaned_data['file']
#                 ext = os.path.splitext(uploaded_file.name)[1].lower()
#                 if ext not in ['.xls', '.xlsx', '.csv']:
#                     messages.error(request, "Invalid file type.")
#                     return redirect('uploadf')

#                 try:
#                     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
#                         for chunk in uploaded_file.chunks():
#                             tmp.write(chunk)
#                         tmp_path = tmp.name

#                     processed_data = parse_excel_file(tmp_path, request, original_filename=uploaded_file.name)
#                     order_id = processed_data.get('order_id')
                    
#                     with transaction.atomic():
#                         save_parsed_data(processed_data, tmp_path)

#                     request.session['uploaded_order_id'] = order_id
#                     request.session['show_upload_summary'] = True

#                     os.remove(tmp_path)
#                     messages.success(request, f"File processed. Order ID: {order_id}")
#                     return redirect(f'/uploadf/?show_upload_form=1&uploaded_order_id={order_id}')

#                 except Exception as e:
#                     if 'tmp_path' in locals() and os.path.exists(tmp_path):
#                         os.remove(tmp_path)
#                     logger.error(f"File processing error: {str(e)}")
#                     messages.error(request, f"Processing error: {str(e)}")
#                     return redirect('uploadf')

#         elif 'order_search' in request.POST:
#             order_search_form = OrderSearchForm(request.POST)
#             if order_search_form.is_valid():
#                 order_id = order_search_form.cleaned_data.get('order_id')
#                 all_results = BomDataRaw.objects.filter(order_id=order_id).select_related()
#                 page = request.GET.get('page', 1)
#                 context_vars['search_results'] = paginate_queryset(all_results, page)
#                 context_vars['order_details'] = OrderDetails.objects.filter(order_id=order_id).first()

#                 if not all_results.exists():
#                     messages.warning(request, f"No BOM data found for Order ID: {order_id}")

#         elif 'component_search_submit' in request.POST:
#             part_number = request.POST.get('component_search', '').strip()
#             component_search_results, component_search_source = fetch_or_cache_component_data(request, part_number)
            
#             # Update currency in component search results
#             if isinstance(component_search_results, dict) and 'price_breaks' in component_search_results:
#                 for price_break in component_search_results['price_breaks']:
#                     if 'currency' in price_break:
#                         price_break['currency'] = 'USD'
#                     if 'price' in price_break:
#                         price_break['formatted_price'] = format_price_usd(price_break['price'])
            
#             context_vars['component_search_results'] = component_search_results
#             context_vars['component_search_source'] = component_search_source

#     # Handle uploaded order display
#     uploaded_order_id_param = request.GET.get('uploaded_order_id')
#     if uploaded_order_id_param or (request.GET.get('show_upload_form') and uploaded_order_id):
#         display_order_id = uploaded_order_id_param or uploaded_order_id
#         if display_order_id:
#             try:
#                 all_results, order_details = get_bom_data_by_order(display_order_id)
#                 if all_results.exists():
#                     page = request.GET.get('page', 1)
#                     context_vars['search_results'] = paginate_queryset(all_results, page)
#                     summary = calculate_bom_summary(all_results)
#                     context_vars.update({
#                         'unique_components_count': summary["unique_components_count"],
#                         'part_not_found': summary["part_not_found"],
#                         'do_not_populate': summary["do_not_populate"],
#                         'part_consigned': summary["part_consigned"],
#                         'order_id': display_order_id,
#                         'order_details': order_details
#                     })
#             except Exception as e:
#                 logger.error(f"Error loading uploaded data: {str(e)}")
#                 messages.error(request, f"Error loading uploaded data: {str(e)}")

#     # Get filtered orders
#     filter_order_id = request.GET.get('filter_order_id')
#     from_date = request.GET.get('from_date')
#     to_date = request.GET.get('to_date')

#     all_orders_query = get_filtered_orders(filter_order_id, from_date, to_date)
#     orders_page = request.GET.get('orders_page', 1)
#     all_orders = paginate_queryset(all_orders_query, orders_page, 10)

#     # BOM Data tab
#     selected_order_id = request.GET.get('order_id')
#     bom_data = None
#     if selected_order_id:
#         try:
#             order = OrderDetails.objects.get(order_id=selected_order_id)
#             all_bom_data = BomDataRaw.objects.filter(order=order).select_related()
#             bom_page = request.GET.get('bom_page', 1)
#             bom_data = paginate_queryset(all_bom_data, bom_page, 20)
#         except OrderDetails.DoesNotExist:
#             bom_data = []

#     # Build query parameters
#     component_search_query = request.GET.get('component_search', '').strip()
#     query_params = {
#         'search_query_params': build_query_params(request, exclude_params=['page']),
#         'orders_query_params': build_query_params(request, exclude_params=['orders_page']),
#         'bom_query_params': build_query_params(request, exclude_params=['bom_page']),
#     }

#     # Build final context
#     context = {
#         'form': form,
#         'order_search_form': order_search_form,
#         'all_orders': all_orders,
#         'bom_data': bom_data,
#         'selected_order_id': selected_order_id,
#         'filter_order_id': filter_order_id,
#         'from_date': from_date,
#         'to_date': to_date,
#         'component_search_query': component_search_query,
#         'excluded_keys': EXCLUDED_KEYS,
#         'uploaded_order_id': uploaded_order_id_param or uploaded_order_id,
#         'currency': 'USD',
#         'currency_symbol': '$',
#         **context_vars,
#         **query_params
#     }

#     return render(request, 'uploadf.html', context)

# def parse_data_field(results):
#     """Optimized data parsing"""
#     for r in results:
#         data = r.get('data')
#         if isinstance(data, str):
#             try:
#                 r['data'] = json.loads(data)
#             except json.JSONDecodeError:
#                 r['data'] = {}
#     return results

# def component_detail_view(request, component_name):
#     parsed_results = []

#     if request.method == 'POST' and request.POST.get('force_external') == '1':
#         part_number = request.POST.get('manufacturer_part_number')
#         result = search_component_by_part_number(part_number)

#         if 'error' in result:
#             messages.error(request, result['error'])
#             context = {
#                 'component_search_query': component_name,
#                 'component_search_results': None,
#                 'component_search_source': 'None',
#                 'show_get_data_button': True,
#                 'currency': 'USD',
#                 'currency_symbol': '$'
#             }
#             return render(request, 'componentdetails.html', context)
#         else:
#             # Update currency in result
#             if 'price_breaks' in result.get('data', {}):
#                 for price_break in result['data']['price_breaks']:
#                     if 'currency' in price_break:
#                         price_break['currency'] = 'USD'
#                     if 'price' in price_break:
#                         price_break['formatted_price'] = format_price_usd(price_break['price'])

#             part = PartSearchData(
#                 manufacturer_part_number=part_number,
#                 data=result['data'],
#                 source=result['source']
#             )
#             part.parsed_data = result['data']
#             parsed_results.append(part)

#             messages.success(request, f"Data fetched from {result['source']}.")
#             context = {
#                 'component_search_query': component_name,
#                 'component_search_results': parsed_results,
#                 'component_search_source': result['source'],
#                 'show_get_data_button': False,
#                 'currency': 'USD',
#                 'currency_symbol': '$'
#             }
#             return render(request, 'componentdetails.html', context)

#     # Use cache for database lookups
#     cache_key = get_cache_key('component_detail', component_name)
#     cached_results = cache.get(cache_key)
    
#     if cached_results:
#         parsed_results = cached_results
#     else:
#         results = PartSearchData.objects.filter(manufacturer_part_number__iexact=component_name)

#         if results.exists():
#             for part in results:
#                 try:
#                     if part.data:
#                         parsed_data = json.loads(part.data) if isinstance(part.data, str) else part.data
                        
#                         # Update currency in parsed data
#                         if 'price_breaks' in parsed_data:
#                             for price_break in parsed_data['price_breaks']:
#                                 if 'currency' in price_break:
#                                     price_break['currency'] = 'USD'
#                                 if 'price' in price_break:
#                                     price_break['formatted_price'] = format_price_usd(price_break['price'])
                        
#                         part.parsed_data = parsed_data
#                     else:
#                         part.parsed_data = {}

#                 except (json.JSONDecodeError, ValidationError) as e:
#                     part.parsed_data = {}
#                     part.json_error = str(e)

#                 parsed_results.append(part)
        
#         # Cache for 10 minutes
#         cache.set(cache_key, parsed_results, 600)

#     context = {
#         'component_search_query': component_name,
#         'component_search_results': parsed_results if parsed_results else None,
#         'component_search_source': 'Database' if parsed_results else 'None',
#         'show_get_data_button': not parsed_results,
#         'currency': 'USD',
#         'currency_symbol': '$'
#     }

#     return render(request, 'componentdetails.html', context)

# def handle_uploaded_file(uploaded_file):
#     """Optimized file handling"""
#     ext = os.path.splitext(uploaded_file.name)[1]
    
#     with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
#         for chunk in uploaded_file.chunks():
#             tmp.write(chunk)
#         return tmp.name

# def component_search_view(request):
#     result = None
#     not_found = False

#     if request.method == 'POST':
#         form = ComponentSearchForm(request.POST)
#         if form.is_valid():
#             part_number = form.cleaned_data['manufacturer_part_number']
#             currency = 'USD'
#             country_code = form.cleaned_data.get('country_code') or 'AT'

#             # Use cache for search results
#             cache_key = get_cache_key('component_search_view', part_number, currency, country_code)
#             cached_result = cache.get(cache_key)
            
#             if cached_result:
#                 result = cached_result
#             else:
#                 result = search_component_by_part_number(part_number, currency, country_code)
                
#                 # Update currency in result
#                 if result and 'price_breaks' in result:
#                     for price_break in result['price_breaks']:
#                         if 'currency' in price_break:
#                             price_break['currency'] = 'USD'
#                         if 'price' in price_break:
#                             price_break['formatted_price'] = format_price_usd(price_break['price'])
                
#                 # Cache for 5 minutes
#                 cache.set(cache_key, result, 300)
            
#             if 'error' in result:
#                 not_found = True
#     else:
#         form = ComponentSearchForm()

#     return render(request, 'component_search.html', {
#         'form': form,
#         'result': result,
#         'not_found': not_found,
#         'currency': 'USD',
#         'currency_symbol': '$'
#     })

# # Component list and price graph views (optimized)
# @cache_page(300)  # Cache for 5 minutes
# def component_list(request):
#     """Optimized view to display all components with search functionality"""
#     search_query = request.GET.get('search', '')
#     page_number = request.GET.get('page', 1)
    
#     # Use cache for component list
#     cache_key = get_cache_key('component_list', search_query, page_number)
#     cached_data = cache.get(cache_key)
    
#     if cached_data:
#         return render(request, 'component_list.html', cached_data)
    
#     # Get unique components with optimized query
#     components_query = ComponentCrons.objects.values('component_name').distinct()
    
#     if search_query:
#         components_query = components_query.filter(component_name__icontains=search_query)
    
#     # Use prefetch_related for better performance
#     component_list = []
#     for comp in components_query:
#         component_name = comp['component_name']
        
#         # Get latest entry and price in single queries
#         latest_entry = ComponentCrons.objects.filter(
#             component_name=component_name
#         ).order_by('-fetched_at').first()
        
#         latest_price = ComponentPrice.objects.filter(
#             part_number=component_name
#         ).order_by('-date', 'quantity').first()
        
#         component_list.append({
#             'name': component_name,
#             'source': latest_entry.source if latest_entry else 'Unknown',
#             'last_updated': latest_entry.fetched_at if latest_entry else None,
#             'latest_price': latest_price.price if latest_price else None,
#             'currency': 'USD',
#             'formatted_price': format_price_usd(latest_price.price) if latest_price else None,
#             'data_points': ComponentPrice.objects.filter(part_number=component_name).count()
#         })
    
#     # Paginate results
#     paginator = Paginator(component_list, 20)
#     page_obj = paginator.get_page(page_number)
    
#     context = {
#         'components': page_obj,
#         'search_query': search_query,
#         'total_components': len(component_list),
#         'currency': 'USD',
#         'currency_symbol': '$'
#     }
    
#     # Cache for 5 minutes
#     cache.set(cache_key, context, 300)
    
#     return render(request, 'component_list.html', context)

# def generate_price_graphs(component_name, days=30):
#     """Optimized price graph generation"""
#     try:
#         # Use cache for graph data
#         cache_key = get_cache_key('price_graphs', component_name, days)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return cached_data

#         today = date.today()
#         start_date = today - timedelta(days=days)
        
#         logger.info(f"Generating graphs for {component_name}")
#         logger.info(f"Date range: {start_date} to {today} ({days} days)")
        
#         # Optimized query with select_related
#         price_data = ComponentPrice.objects.filter(
#             part_number=component_name,
#             date__gte=start_date,
#             date__lte=today
#         ).order_by('date', 'quantity')
        
#         logger.info(f"Found {price_data.count()} price records")
        
#         if not price_data.exists():
#             logger.warning(f"No price data found for {component_name}")
#             return None, None, []
        
#         # Group data by quantity more efficiently
#         quantity_data = defaultdict(list)
#         for price in price_data:
#             quantity_data[price.quantity].append({
#                 'date': price.date,
#                 'price': float(price.price),
#                 'currency': 'USD'
#             })
        
#         sorted_quantities = sorted(quantity_data.keys())
#         currency = 'USD'
        
#         if not sorted_quantities:
#             return None, None, []
        
#         logger.info(f"Processing {len(sorted_quantities)} different quantities: {sorted_quantities}")
        
#         # Optimize matplotlib settings
#         plt.style.use('default')
#         plt.rcParams.update({
#             'figure.facecolor': 'white',
#             'axes.facecolor': 'white',
#             'font.size': 12,
#             'axes.titlesize': 16,
#             'axes.labelsize': 14,
#             'xtick.labelsize': 12,
#             'ytick.labelsize': 12,
#             'legend.fontsize': 11
#         })
        
#         fig, ax = plt.subplots(figsize=(16, 10))
        
#         colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
#                   '#06B6D4', '#84CC16', '#F97316', '#EC4899', '#6366F1',
#                   '#14B8A6', '#F472B6', '#A855F7', '#22D3EE', '#FDE047']
        
#         graphs_data = []
        
#         for idx, quantity in enumerate(sorted_quantities):
#             data = quantity_data[quantity]
#             dates = [item['date'] for item in data]
#             prices = [item['price'] for item in data]
            
#             logger.info(f"Quantity {quantity}: {len(dates)} data points")
            
#             color = colors[idx % len(colors)]
#             ax.plot(dates, prices, 
#                    marker='o', 
#                    linewidth=3, 
#                    markersize=6, 
#                    color=color, 
#                    label=f'{quantity:,} pcs',
#                    markerfacecolor='white', 
#                    markeredgewidth=2, 
#                    markeredgecolor=color,
#                    alpha=0.8)
            
#             if prices:
#                 graphs_data.append({
#                     'quantity': quantity,
#                     'min_price': min(prices),
#                     'max_price': max(prices),
#                     'avg_price': sum(prices) / len(prices),
#                     'data_points': len(prices),
#                     'currency': currency,
#                     'formatted_min_price': format_price_usd(min(prices)),
#                     'formatted_max_price': format_price_usd(max(prices)),
#                     'formatted_avg_price': format_price_usd(sum(prices) / len(prices)),
#                     'date_range': f"{min(dates).strftime('%m/%d')} - {max(dates).strftime('%m/%d')}"
#                 })
        
#         # Customize chart
#         title = f'Price Trends for {component_name}\n({start_date.strftime("%b %d, %Y")} to {today.strftime("%b %d, %Y")} - {days} days)'
#         ax.set_title(title, fontsize=18, fontweight='bold', pad=30)
#         ax.set_xlabel('Date', fontsize=14, fontweight='500')
#         ax.set_ylabel('Price (USD)', fontsize=14, fontweight='500')
#         ax.grid(True, alpha=0.3, linestyle='--')
#         ax.set_facecolor('#FAFAFA')
        
#         # Format dates
#         actual_dates = list(price_data.values_list('date', flat=True).distinct().order_by('date'))
#         if actual_dates:
#             ax.set_xlim(min(actual_dates), max(actual_dates))
            
#             if days <= 7:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
#             elif days <= 30:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(actual_dates)//8)))
#             elif days <= 90:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=max(1, len(actual_dates)//10)))
#             else:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%y'))
#                 ax.xaxis.set_major_locator(mdates.MonthLocator(interval=max(1, len(actual_dates)//8)))
            
#             plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
#         ax.margins(x=0.01, y=0.05)
        
#         # Add legend
#         legend = ax.legend(loc='upper left', 
#                           bbox_to_anchor=(0.02, 0.98),
#                           frameon=True, 
#                           fancybox=True, 
#                           shadow=True,
#                           ncol=min(3, len(sorted_quantities)),
#                           fontsize=11)
#         legend.get_frame().set_facecolor('white')
#         legend.get_frame().set_alpha(0.9)
        
#         # Style axes
#         ax.spines['top'].set_visible(False)
#         ax.spines['right'].set_visible(False)
#         ax.spines['left'].set_color('#E5E7EB')
#         ax.spines['bottom'].set_color('#E5E7EB')
        
#         plt.tight_layout()
#         plt.subplots_adjust(top=0.85, bottom=0.15, left=0.08, right=0.95)
        
#         # Convert to base64
#         buffer = io.BytesIO()
#         plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight', 
#                     facecolor='white', edgecolor='none', pad_inches=0.3)
#         buffer.seek(0)
#         image_base64 = base64.b64encode(buffer.getvalue()).decode()
#         plt.close()
        
#         # Create summary graph
#         summary_image_base64 = None
#         if len(graphs_data) > 1:
#             try:
#                 summary_fig, summary_ax = plt.subplots(figsize=(14, 8))
#                 summary_fig.patch.set_facecolor('white')
                
#                 quantities_list = [data['quantity'] for data in graphs_data]
#                 avg_prices = [data['avg_price'] for data in graphs_data]
#                 min_prices = [data['min_price'] for data in graphs_data]
#                 max_prices = [data['max_price'] for data in graphs_data]
                
#                 x = np.arange(len(quantities_list))
#                 width = 0.25
                
#                 bars1 = summary_ax.bar(x - width, min_prices, width, label='Min Price', 
#                                       color='#10B981', alpha=0.8, edgecolor='white', linewidth=2)
#                 bars2 = summary_ax.bar(x, avg_prices, width, label='Avg Price', 
#                                       color='#3B82F6', alpha=0.8, edgecolor='white', linewidth=2)
#                 bars3 = summary_ax.bar(x + width, max_prices, width, label='Max Price', 
#                                       color='#EF4444', alpha=0.8, edgecolor='white', linewidth=2)
                
#                 summary_ax.set_xlabel('Quantity (pieces)', fontsize=12, fontweight='500')
#                 summary_ax.set_ylabel('Price (USD)', fontsize=12, fontweight='500')
#                 summary_ax.set_title(f'Price Summary for {component_name}\n({start_date.strftime("%b %d")} - {today.strftime("%b %d, %Y")})', 
#                                     fontsize=16, fontweight='bold', pad=20)
#                 summary_ax.set_xticks(x)
#                 summary_ax.set_xticklabels([f'{q:,}' for q in quantities_list])
#                 summary_ax.legend(frameon=False, loc='upper left')
#                 summary_ax.grid(True, alpha=0.3, axis='y', linestyle='--')
#                 summary_ax.set_facecolor('#FAFAFA')
                
#                 summary_ax.spines['top'].set_visible(False)
#                 summary_ax.spines['right'].set_visible(False)
#                 summary_ax.spines['left'].set_color('#E5E7EB')
#                 summary_ax.spines['bottom'].set_color('#E5E7EB')
                
#                 # Add value labels with $ symbol
#                 def add_value_labels(bars, values):
#                     for bar, value in zip(bars, values):
#                         height = bar.get_height()
#                         summary_ax.text(bar.get_x() + bar.get_width()/2., height + max(max_prices) * 0.02,
#                                        format_price_usd(value), ha='center', va='bottom', fontsize=10, fontweight='bold')
                
#                 add_value_labels(bars1, min_prices)
#                 add_value_labels(bars2, avg_prices)
#                 add_value_labels(bars3, max_prices)
                
#                 plt.tight_layout()
                
#                 summary_buffer = io.BytesIO()
#                 plt.savefig(summary_buffer, format='png', dpi=200, bbox_inches='tight',
#                            facecolor='white', edgecolor='none', pad_inches=0.2)
#                 summary_buffer.seek(0)
#                 summary_image_base64 = base64.b64encode(summary_buffer.getvalue()).decode()
#                 plt.close()
#             except Exception as e:
#                 logger.error(f"Error creating summary graph: {e}")
#                 summary_image_base64 = None
        
#         result = (image_base64, summary_image_base64, graphs_data)
        
#         # Cache for 30 minutes
#         cache.set(cache_key, result, 1800)
        
#         logger.info(f"Successfully generated graphs for {component_name} with {len(graphs_data)} quantities")
#         return result
        
#     except Exception as e:
#         logger.error(f"Error generating graphs for {component_name}: {e}")
#         return None, None, []

# def component_price_graph(request, component_name):
#     """Optimized view to display price graph for a specific component"""
#     try:
#         component = ComponentCrons.objects.filter(component_name=component_name).first()
#     except Exception as e:
#         logger.error(f"Error fetching component {component_name}: {e}")
#         component = None
    
#     days = int(request.GET.get('days', 30))
#     logger.info(f"Loading component_price_graph for {component_name}, days: {days}")
    
#     # Generate graphs
#     price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
    
#     # Get component details
#     latest_entry = ComponentCrons.objects.filter(
#         component_name=component_name
#     ).order_by('-fetched_at').first()
    
#     context = {
#         'component_name': component_name,
#         'component': latest_entry,
#         'price_graph': price_graph,
#         'summary_graph': summary_graph,
#         'graphs_data': graphs_data,
#         'currency': 'USD',
#         'currency_symbol': '$',
#         'selected_days': days,
#         'has_data': price_graph is not None
#     }
    
#     logger.info(f"Context: has_data={context['has_data']}, selected_days={context['selected_days']}")
#     return render(request, 'component_price_graph.html', context)

# def component_price_api(request, component_name):
#     """Optimized API endpoint to get price data for AJAX requests"""
#     days = int(request.GET.get('days', 30))
#     logger.info(f"API call for {component_name}, days: {days}")
    
#     try:
#         price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
        
#         response_data = {
#             'price_graph': price_graph,
#             'summary_graph': summary_graph,
#             'graphs_data': graphs_data,
#             'has_data': price_graph is not None,
#             'currency': 'USD',
#             'currency_symbol': '$',
#             'days': days
#         }
        
#         logger.info(f"API response: has_data={response_data['has_data']}, days={days}")
#         return JsonResponse(response_data)
        
#     except Exception as e:
#         logger.error(f"API error for {component_name}: {e}")
#         return JsonResponse({
#             'error': str(e),
#             'has_data': False,
#             'price_graph': None,
#             'summary_graph': None,
#             'graphs_data': [],
#             'currency': 'USD',
#             'currency_symbol': '$',
#             'days': days
#         }, status=500)




from django.shortcuts import render, redirect
from django.contrib.auth import authenticate, login, logout
from rest_framework import generics
from django.db.models import Q, Prefetch, Count, Sum, Avg, Min, Max
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.parsers import MultiPartParser, FormParser
from rest_framework import status
from django.core.cache import cache
from django.db import transaction
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.views.decorators.gzip import gzip_page
import logging
import warnings
from collections import defaultdict
from django.http import HttpResponse, JsonResponse
from django.contrib import messages
from django.core.paginator import Paginator
from urllib.parse import urlencode
import os
import tempfile
import json
from django.core.exceptions import ValidationError
from datetime import datetime, timedelta, date
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import io
import base64
import pandas as pd
import numpy as np
from functools import lru_cache
import time

# Your imports
from .models import (
    Excelfile, OrderDetails, Manufacturers, Components, Suppliers, BomDetails,
    ComponentOrderData, RawData, BomDataRaw, PartSearchData, ComponentCrons, ComponentPrice
)
from .serializers import (
    ExcelFileSerializer, BomDetailsSerializer, SupplierSummarySerializer,
    ManufacturerSerializer, ComponentOrderDataSerializer, SupplierSerializer,
    RawDataSerializer, BomDataRawSerializer
)
from .forms import UploadFileForm, OrderSearchForm, SignUpForm, ComponentSearchForm
from .service import (
    paginate_queryset, calculate_bom_summary, get_bom_data_by_order,
    get_filtered_orders, search_component_by_part_number, search_mouser_component,
    fetch_from_oem_secrets, fetch_or_cache_component_data
)
from .process_excel_file import process_excel_file, parse_excel_file, save_parsed_data

# Configure logging
warnings.simplefilter(action='ignore', category=FutureWarning)
logger = logging.getLogger(__name__)

# OPTIMIZED CONSTANTS
INVALID_MANUFACTURERS = ['mpi', 'dpi', 'dnp', 'mnp', '-', '#N/A', 'Consigned']
INVALID_SUPPLIERS = ['dpi', 'dnp', 'snp', '-', '#N/A']
INVALID_COMPONENTS = [
    'cna', '-', '#N/A', 'N/A', 'n/a', 'dnp', 'dni1', 'dni2', 'dni3',
    'Do Not Stuff', '-DNI', 'none', 'no load', '[noparam]', 'Consigned',
    'NP', 'Generic', 'DO NOT PLACE', 'DO NOT POPULATE', 'NO POP 1', 'NO POP'
]
SKIP_VALUES = [
    'DNI', 'DNP', 'MNP', 'CNA', 'SCNA', 'SNP', '-', '#N/A', 'DNI 1', 'DNI 2',
    'DNI 3', 'Do Not Stuff', '-DNI', 'none', 'no load', '[noparam]',
    'Consigned', 'NP', 'Generic', 'DO NOT PLACE', 'DO NOT POPULATE', 'NO POP 1', 'NO POP'
]
EXCLUDED_KEYS = [
    "Manufacturer", "ManufacturerPartNumber", "MouserPartNumber", "Category",
    "Min", "Availability", "FactoryStock", "LeadTime", "AvailabilityInStock",
    "PriceBreaks", "ProductAttributes", "DataSheetUrl", "ProductDetailUrl",
    "AlternatePackagings", "ProductCompliance", "Description", "ROHSStatus", "ImagePath"
]

# Cache timeouts
CACHE_SHORT = 300      # 5 minutes
CACHE_MEDIUM = 900     # 15 minutes  
CACHE_LONG = 3600      # 1 hour

# UTILITY FUNCTIONS
def performance_monitor(func):
    """Decorator to monitor function performance"""
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        logger.info(f"{func.__name__} executed in {end_time - start_time:.4f} seconds")
        return result
    return wrapper

@lru_cache(maxsize=1000)
def build_case_insensitive_q_cached(field_name, values_tuple):
    """Cached Q object builder for better performance"""
    q = Q()
    for value in values_tuple:
        q |= Q(**{f"{field_name}__iexact": value})
    return q

def build_case_insensitive_q(field_name, values):
    """Build case-insensitive Q object for multiple values"""
    return build_case_insensitive_q_cached(field_name, tuple(values))

@lru_cache(maxsize=10000)
def format_price_usd(price):
    """Cached price formatting with USD symbol"""
    return f"${float(price):.2f}" if price else "$0.00"

def get_cache_key(prefix, *args):
    """Generate cache key"""
    return f"{prefix}:{'_'.join(str(arg) for arg in args)}"

# VIEWS - KEEPING ORIGINAL CLASS NAMES
def home(request):
    return HttpResponse("Welcome to the Excel Upload API. Use /api/upload/ to upload your Excel file.")

class UploadExcelView(APIView):
    parser_classes = [MultiPartParser, FormParser]

    @performance_monitor
    def post(self, request, *args, **kwargs):
        file_serializer = ExcelFileSerializer(data=request.data)
        if file_serializer.is_valid():
            with transaction.atomic():
                file_instance = file_serializer.save()
                excel_file = file_instance.file.path
                return process_excel_file(excel_file, request, return_json=True)
        return Response(file_serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class BomByOrderIDView(APIView):
    
    @performance_monitor
    def get(self, request, order_id):
        # Use cache for frequently accessed data
        cache_key = get_cache_key('bom_order', order_id)
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data, status=status.HTTP_200_OK)

        try:
            order = OrderDetails.objects.get(order_id=order_id)
        except OrderDetails.DoesNotExist:
            return Response({"error": "Order ID not found."}, status=status.HTTP_404_NOT_FOUND)

        # Use select_related to reduce database queries
        bom_entries = BomDetails.objects.filter(order=order).select_related(
            'manufacturer', 'component', 'supplier'
        )
        
        serializer = BomDetailsSerializer(bom_entries, many=True)

        # Optimize data grouping using defaultdict
        manufacturer_data = defaultdict(list)
        supplier_data = defaultdict(list)
        
        for entry in bom_entries:
            manufacturer = str(entry.manufacturer or "MNP")
            component = str(entry.component or "CNA")
            supplier = str(entry.supplier or "SNP")
            supplier_part_no = str(entry.supplier_component or "SCNA")
            unit_price = float(entry.unit_price or 0)
            
            manufacturer_data[manufacturer].append(component)
            supplier_data[supplier].append({
                "supplier_part_no": supplier_part_no,
                "unit_price": unit_price
            })

        # Build summaries more efficiently
        manufacturer_summary = [
            {
                "manufacturer": manufacturer,
                "components": [{"component_name": comp} for comp in components]
            }
            for manufacturer, components in manufacturer_data.items()
        ]

        supplier_summary = [
            {
                "supplier": supplier,
                "parts": parts,
                "total_unit_price": sum(part['unit_price'] for part in parts),
                "currency": "USD"  # Changed from INR to USD
            }
            for supplier, parts in supplier_data.items()
        ]

        response_data = {
            "bom_details": serializer.data,
            "manufacturer_summary": manufacturer_summary,
            "supplier_summary": SupplierSummarySerializer(supplier_summary, many=True).data,
            "currency": "USD"  # Changed from INR to USD
        }
        
        # Cache the result for 15 minutes
        cache.set(cache_key, response_data, CACHE_MEDIUM)
        
        return Response(response_data, status=status.HTTP_200_OK)

@method_decorator(cache_page(CACHE_SHORT), name='get')
class ManufacturerListView(APIView):
    def get(self, request):
        manufacturers = Manufacturers.objects.all()
        serializer = ManufacturerSerializer(manufacturers, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

@method_decorator(cache_page(CACHE_SHORT), name='get')
class SupplierListView(APIView):
    def get(self, request):
        suppliers = Suppliers.objects.all()
        serializer = SupplierSerializer(suppliers, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)

class ComponentOrderIDsView(APIView):
    @performance_monitor
    def get(self, request, *args, **kwargs):
        component_name = request.query_params.get("component_name")
        if not component_name:
            return Response(
                {"error": "component_name parameter is required."}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        # Use cache for component lookups
        cache_key = get_cache_key('component_orders', component_name)
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data)

        try:
            component = Components.objects.filter(component__iexact=component_name).first()
            if not component:
                return Response(
                    {"error": "Component not found."}, 
                    status=status.HTTP_404_NOT_FOUND
                )

            if component.component.strip().lower() in ['cna', 'na', 'n / a', '-']:
                return Response(
                    {"error": "Component is not valid (N/A)."}, 
                    status=status.HTTP_400_BAD_REQUEST
                )

            # Use values_list with flat=True for better performance
            order_ids = list(
                BomDetails.objects
                .filter(component=component)
                .values_list("order_id", flat=True)
                .distinct()
            )

            response_data = {
                "component_name": component.component,
                "order_ids": order_ids,
                "total_orders": len(order_ids)
            }
            
            # Cache for 10 minutes
            cache.set(cache_key, response_data, CACHE_SHORT * 2)
            
            return Response(response_data)

        except Exception as e:
            logger.error(f"Error in ComponentOrderIDsView: {str(e)}")
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

class BulkComponentOrderIDsView(APIView):
    @performance_monitor
    @transaction.atomic
    def post(self, request, *args, **kwargs):
        # Use select_related to optimize query
        components = Components.objects.exclude(
            component__icontains='CNA'
        ).select_related()[:100]
        
        created_data = []

        for component in components:
            if component.component.strip().lower() in INVALID_COMPONENTS:
                continue

            order_ids = list(
                BomDetails.objects
                .filter(component=component)
                .values_list("order_id", flat=True)
                .distinct()
            )

            if len(order_ids) < 2:
                continue

            # Use get_or_create more efficiently
            data, created = ComponentOrderData.objects.get_or_create(
                component_name=component.component,
                defaults={
                    'order_ids': order_ids,
                    'total_orders': len(order_ids)
                }
            )
            created_data.append(data)

        serializer = ComponentOrderDataSerializer(created_data, many=True)
        return Response({
            "message": f"Order data stored for {len(created_data)} components (excluding unknown/CNP/low-count).",
            "data": serializer.data
        }, status=status.HTTP_201_CREATED)

class RawDataListAPIView(generics.ListAPIView):
    serializer_class = RawDataSerializer

    def get_queryset(self):
        queryset = RawData.objects.select_related().all()
        order_id = self.request.query_params.get('order_id')
        if order_id:
            queryset = queryset.filter(order_id=order_id)
        return queryset

    @performance_monitor
    def list(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        serializer = self.get_serializer(queryset, many=True)

        # Optimize counting using cache
        cache_key = get_cache_key('raw_data_counts', request.query_params.get('order_id', 'all'))
        type_counts = cache.get(cache_key)
        
        if not type_counts:
            type_counts = {}
            for skip_value in SKIP_VALUES:
                count = queryset.filter(
                    Q(component__iexact=skip_value) |
                    Q(manufacturer__iexact=skip_value) |
                    Q(supplier_part_no__iexact=skip_value) |
                    Q(supplier__iexact=skip_value)
                ).count()
                type_counts[skip_value.lower()] = count
            
            cache.set(cache_key, type_counts, CACHE_SHORT)

        return Response({
            'order_id': request.query_params.get('order_id'),
            'counts': type_counts,
            'data': serializer.data,
            'currency': 'USD'  # Changed from INR to USD
        }, status=status.HTTP_200_OK)

class ComponentsWithoutValidManufacturerView(APIView):
    @performance_monitor
    def get(self, request):
        # Use cache
        cache_key = get_cache_key('invalid_manufacturers')
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data, status=status.HTTP_200_OK)

        # Use optimized Q objects
        manufacturer_q = build_case_insensitive_q('manufacturer', INVALID_MANUFACTURERS)
        component_q = build_case_insensitive_q('component', INVALID_COMPONENTS)

        filtered_data = list(RawData.objects.filter(
            manufacturer_q
        ).exclude(
            component_q
        ).values('component', 'manufacturer'))

        cache.set(cache_key, filtered_data, CACHE_MEDIUM)
        return Response(filtered_data, status=status.HTTP_200_OK)

class ComponentWithoutSupplierView(APIView):
    @performance_monitor
    def get(self, request):
        # Use cache
        cache_key = get_cache_key('invalid_suppliers')
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data, status=status.HTTP_200_OK)

        # Use optimized Q objects
        supplier_q = build_case_insensitive_q('supplier', INVALID_SUPPLIERS)
        component_q = build_case_insensitive_q('component', INVALID_COMPONENTS)

        filtered_data = list(RawData.objects.filter(
            supplier_q
        ).exclude(
            component_q
        ).values('component', 'supplier'))

        cache.set(cache_key, filtered_data, CACHE_MEDIUM)
        return Response(filtered_data, status=status.HTTP_200_OK)

class BomDataRawByOrderView(APIView):
    @performance_monitor
    def get(self, request, order_id):
        try:
            order = OrderDetails.objects.get(order_id=order_id)
        except OrderDetails.DoesNotExist:
            return Response({"error": "Order not found"}, status=404)

        # Use select_related for optimization
        queryset = BomDataRaw.objects.filter(order=order).select_related()
        serializer = BomDataRawSerializer(queryset, many=True)

        return Response({
            "data": serializer.data,
            "currency": "USD"  # Changed from INR to USD
        }, status=200)

class OrderSearchAPIView(APIView):
    @performance_monitor
    def post(self, request):
        order_id = request.data.get('order_id')
        if not order_id:
            return Response({'error': 'order_id is required'}, status=status.HTTP_400_BAD_REQUEST)

        # Use select_related for optimization
        bom_qs = BomDataRaw.objects.filter(order_id=order_id).select_related()
        order_details = OrderDetails.objects.filter(order_id=order_id).first()

        if not bom_qs.exists():
            return Response({'message': f'No BOM data found for Order ID: {order_id}'}, status=404)

        page = request.GET.get('page', 1)
        paginated = paginate_queryset(bom_qs, page)

        return Response({
            'bom_data': BomDataRawSerializer(paginated, many=True).data,
            'order_details': BomDataRawSerializer(order_details).data if order_details else None,
            'currency': 'USD'  # Changed from INR to USD
        })

class ComponentSearchAPIView(APIView):
    @performance_monitor
    def post(self, request):
        part_number = request.data.get('part_number', '').strip()
        if not part_number:
            return Response({'error': 'part_number is required'}, status=400)

        # Use cache for component search results
        cache_key = get_cache_key('component_search', part_number)
        cached_result = cache.get(cache_key)
        
        if cached_result:
            return Response(cached_result)

        result, source = fetch_or_cache_component_data(request, part_number)
        
        # Update currency in result if present
        if isinstance(result, dict) and 'price_breaks' in result:
            for price_break in result['price_breaks']:
                if 'currency' in price_break:
                    price_break['currency'] = 'USD'  # Changed from INR to USD
                if 'price' in price_break:
                    price_break['formatted_price'] = format_price_usd(price_break['price'])

        response_data = {
            'component': result,
            'source': source,
            'currency': 'USD'  # Changed from INR to USD
        }
        
        # Cache for 5 minutes
        cache.set(cache_key, response_data, CACHE_SHORT)
        
        return Response(response_data)

class UploadedOrderSummaryAPIView(APIView):
    @performance_monitor
    def get(self, request):
        order_id = request.query_params.get('uploaded_order_id')
        if not order_id:
            return Response({'error': 'uploaded_order_id is required'}, status=400)

        # Use cache for summary data
        cache_key = get_cache_key('order_summary', order_id)
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data)

        try:
            all_results, order_details = get_bom_data_by_order(order_id)
            if not all_results.exists():
                return Response({'message': 'No data found'}, status=404)

            summary = calculate_bom_summary(all_results)
            
            if 'total_cost' in summary:
                summary['formatted_total_cost'] = format_price_usd(summary['total_cost'])
            
            response_data = {
                'order_id': order_id,
                'summary': summary,
                'order_details': BomDataRawSerializer(order_details).data,
                'currency': 'USD'  # Changed from INR to USD
            }
            
            # Cache for 10 minutes
            cache.set(cache_key, response_data, CACHE_SHORT * 2)
            
            return Response(response_data)

        except Exception as e:
            logger.error(f"Error in UploadedOrderSummaryAPIView: {str(e)}")
            return Response({'error': str(e)}, status=500)

class OrderListAPIView(APIView):
    @performance_monitor
    def get(self, request):
        filter_order_id = request.query_params.get('filter_order_id')
        from_date = request.query_params.get('from_date')
        to_date = request.query_params.get('to_date')

        # Use cache for filtered orders
        cache_key = get_cache_key('filtered_orders', filter_order_id, from_date, to_date)
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return Response(cached_data)

        queryset = get_filtered_orders(filter_order_id, from_date, to_date)
        page = request.query_params.get('page', 1)
        paginated = paginate_queryset(queryset, page, 10)

        response_data = {
            'orders': BomDataRawSerializer(paginated, many=True).data,
            'currency': 'USD'  # Changed from INR to USD
        }
        
        # Cache for 5 minutes
        cache.set(cache_key, response_data, CACHE_SHORT)
        
        return Response(response_data)

# AUTHENTICATION VIEWS
def signup_view(request):
    if request.method == 'POST':
        form = SignUpForm(request.POST)
        if form.is_valid():
            with transaction.atomic():
                user = form.save(commit=False)
                user.set_password(form.cleaned_data['password'])
                user.save()
            messages.success(request, 'Account created successfully!')
            return redirect('login')
    else:
        form = SignUpForm()

    return render(request, 'accounts/signup.html', {'form': form})

def login_view(request):
    if request.method == 'POST':
        username = request.POST['username']
        password = request.POST['password']

        user = authenticate(request, username=username, password=password)
        if user is not None:
            login(request, user)
            messages.success(request, "Login successful!")
            return redirect('uploadf')
        else:
            messages.error(request, "Invalid credentials")
            return render(request, 'accounts/login.html', {'error': 'Invalid credentials'})

    return render(request, 'accounts/login.html')

def logout_view(request):
    logout(request)
    return redirect('login')

def upload_view(request):
    if request.method == 'POST':
        form = UploadFileForm(request.POST, request.FILES)
        if form.is_valid():
            return redirect('success')
    else:
        form = UploadFileForm()

    return render(request, 'uploadf.html', {'form': form})

def build_query_params(request, exclude_params=None):
    """Optimized helper function to build query parameters for pagination"""
    if exclude_params is None:
        exclude_params = []
    
    return urlencode({
        key: value for key, value in request.GET.items()
        if key not in exclude_params and value
    })

@performance_monitor
def upload_file(request):
    # Initialize variables efficiently
    context_vars = {
        'search_results': None,
        'processed_data': None,
        'order_id': None,
        'order_details': None,
        'unique_components_count': 0,
        'part_not_found': 0,
        'do_not_populate': 0,
        'part_consigned': 0,
        'component_search_results': None,
        'component_search_source': None,
    }
    
    form = UploadFileForm()
    order_search_form = OrderSearchForm()
    uploaded_order_id = request.session.get('uploaded_order_id')

    if request.method == 'POST':
        if 'file_upload' in request.POST:
            form = UploadFileForm(request.POST, request.FILES)
            if not request.FILES.get('file'):
                messages.error(request, "No file selected.")
                return redirect('uploadf')

            if form.is_valid():
                uploaded_file = form.cleaned_data['file']
                ext = os.path.splitext(uploaded_file.name)[1].lower()
                if ext not in ['.xls', '.xlsx', '.csv']:
                    messages.error(request, "Invalid file type.")
                    return redirect('uploadf')

                try:
                    with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
                        for chunk in uploaded_file.chunks():
                            tmp.write(chunk)
                        tmp_path = tmp.name

                    processed_data = parse_excel_file(tmp_path, request, original_filename=uploaded_file.name)
                    order_id = processed_data.get('order_id')
                    
                    with transaction.atomic():
                        save_parsed_data(processed_data, tmp_path)

                    request.session['uploaded_order_id'] = order_id
                    request.session['show_upload_summary'] = True

                    os.remove(tmp_path)
                    messages.success(request, f"File processed. Order ID: {order_id}")
                    return redirect(f'/uploadf/?show_upload_form=1&uploaded_order_id={order_id}')

                except Exception as e:
                    if 'tmp_path' in locals() and os.path.exists(tmp_path):
                        os.remove(tmp_path)
                    logger.error(f"File processing error: {str(e)}")
                    messages.error(request, f"Processing error: {str(e)}")
                    return redirect('uploadf')

        elif 'order_search' in request.POST:
            order_search_form = OrderSearchForm(request.POST)
            if order_search_form.is_valid():
                order_id = order_search_form.cleaned_data.get('order_id')
                all_results = BomDataRaw.objects.filter(order_id=order_id).select_related()
                page = request.GET.get('page', 1)
                context_vars['search_results'] = paginate_queryset(all_results, page)
                context_vars['order_details'] = OrderDetails.objects.filter(order_id=order_id).first()

                if not all_results.exists():
                    messages.warning(request, f"No BOM data found for Order ID: {order_id}")

        elif 'component_search_submit' in request.POST:
            part_number = request.POST.get('component_search', '').strip()
            component_search_results, component_search_source = fetch_or_cache_component_data(request, part_number)
            
            # Update currency in component search results
            if isinstance(component_search_results, dict) and 'price_breaks' in component_search_results:
                for price_break in component_search_results['price_breaks']:
                    if 'currency' in price_break:
                        price_break['currency'] = 'USD'  # Changed from INR to USD
                    if 'price' in price_break:
                        price_break['formatted_price'] = format_price_usd(price_break['price'])
            
            context_vars['component_search_results'] = component_search_results
            context_vars['component_search_source'] = component_search_source

    # Handle uploaded order display
    uploaded_order_id_param = request.GET.get('uploaded_order_id')
    if uploaded_order_id_param or (request.GET.get('show_upload_form') and uploaded_order_id):
        display_order_id = uploaded_order_id_param or uploaded_order_id
        if display_order_id:
            try:
                all_results, order_details = get_bom_data_by_order(display_order_id)
                if all_results.exists():
                    page = request.GET.get('page', 1)
                    context_vars['search_results'] = paginate_queryset(all_results, page)
                    summary = calculate_bom_summary(all_results)
                    context_vars.update({
                        'unique_components_count': summary["unique_components_count"],
                        'part_not_found': summary["part_not_found"],
                        'do_not_populate': summary["do_not_populate"],
                        'part_consigned': summary["part_consigned"],
                        'order_id': display_order_id,
                        'order_details': order_details
                    })
            except Exception as e:
                logger.error(f"Error loading uploaded data: {str(e)}")
                messages.error(request, f"Error loading uploaded data: {str(e)}")

    # Get filtered orders
    filter_order_id = request.GET.get('filter_order_id')
    from_date = request.GET.get('from_date')
    to_date = request.GET.get('to_date')

    all_orders_query = get_filtered_orders(filter_order_id, from_date, to_date)
    orders_page = request.GET.get('orders_page', 1)
    all_orders = paginate_queryset(all_orders_query, orders_page, 10)

    # BOM Data tab
    selected_order_id = request.GET.get('order_id')
    bom_data = None
    if selected_order_id:
        try:
            order = OrderDetails.objects.get(order_id=selected_order_id)
            all_bom_data = BomDataRaw.objects.filter(order=order).select_related()
            bom_page = request.GET.get('bom_page', 1)
            bom_data = paginate_queryset(all_bom_data, bom_page, 20)
            top_components = BomDataRaw.objects.filter(order=order).order_by('-price')[:5]
        except OrderDetails.DoesNotExist:
            bom_data = []

    # Build query parameters
    component_search_query = request.GET.get('component_search', '').strip()
    query_params = {
        'search_query_params': build_query_params(request, exclude_params=['page']),
        'orders_query_params': build_query_params(request, exclude_params=['orders_page']),
        'bom_query_params': build_query_params(request, exclude_params=['bom_page']),
    }

    # Build final context
    context = {
        'form': form,
        'order_search_form': order_search_form,
        'all_orders': all_orders,
        'bom_data': bom_data,
        'selected_order_id': selected_order_id,
        'filter_order_id': filter_order_id,
        'from_date': from_date,
        'to_date': to_date,
        'component_search_query': component_search_query,
        'excluded_keys': EXCLUDED_KEYS,
        'uploaded_order_id': uploaded_order_id_param or uploaded_order_id,
        'currency': 'USD',  # Changed from INR to USD
        'currency_symbol': '$',  # Added $ symbol
        # 'top_components': top_components,
        **context_vars,
        **query_params
    }

    return render(request, 'uploadf.html', context)

def parse_data_field(results):
    """Optimized data parsing"""
    for r in results:
        data = r.get('data')
        if isinstance(data, str):
            try:
                r['data'] = json.loads(data)
            except json.JSONDecodeError:
                r['data'] = {}
    return results

@performance_monitor
def component_detail_view(request, component_name):
    parsed_results = []

    if request.method == 'POST' and request.POST.get('force_external') == '1':
        part_number = request.POST.get('manufacturer_part_number')
        result = search_component_by_part_number(part_number)

        if 'error' in result:
            messages.error(request, result['error'])
            context = {
                'component_search_query': component_name,
                'component_search_results': None,
                'component_search_source': 'None',
                'show_get_data_button': True,
                'currency': 'USD',  # Changed from INR to USD
                'currency_symbol': '$'  # Added $ symbol
            }
            return render(request, 'componentdetails.html', context)
        else:
            # Update currency in result
            if 'price_breaks' in result.get('data', {}):
                for price_break in result['data']['price_breaks']:
                    if 'currency' in price_break:
                        price_break['currency'] = 'USD'  # Changed from INR to USD
                    if 'price' in price_break:
                        price_break['formatted_price'] = format_price_usd(price_break['price'])

            part = PartSearchData(
                manufacturer_part_number=part_number,
                data=result['data'],
                source=result['source']
            )
            part.parsed_data = result['data']
            parsed_results.append(part)

            messages.success(request, f"Data fetched from {result['source']}.")
            context = {
                'component_search_query': component_name,
                'component_search_results': parsed_results,
                'component_search_source': result['source'],
                'show_get_data_button': False,
                'currency': 'USD',  # Changed from INR to USD
                'currency_symbol': '$'  # Added $ symbol
            }
            return render(request, 'componentdetails.html', context)

    # Use cache for database lookups
    cache_key = get_cache_key('component_detail', component_name)
    cached_results = cache.get(cache_key)
    
    if cached_results:
        parsed_results = cached_results
    else:
        results = PartSearchData.objects.filter(manufacturer_part_number__iexact=component_name)

        if results.exists():
            for part in results:
                try:
                    if part.data:
                        parsed_data = json.loads(part.data) if isinstance(part.data, str) else part.data
                        
                        # Update currency in parsed data
                        if 'price_breaks' in parsed_data:
                            for price_break in parsed_data['price_breaks']:
                                if 'currency' in price_break:
                                    price_break['currency'] = 'USD'  # Changed from INR to USD
                                if 'price' in price_break:
                                    price_break['formatted_price'] = format_price_usd(price_break['price'])
                        
                        part.parsed_data = parsed_data
                    else:
                        part.parsed_data = {}

                except (json.JSONDecodeError, ValidationError) as e:
                    part.parsed_data = {}
                    part.json_error = str(e)

                parsed_results.append(part)
        
        # Cache for 10 minutes
        cache.set(cache_key, parsed_results, CACHE_SHORT * 2)

    context = {
        'component_search_query': component_name,
        'component_search_results': parsed_results if parsed_results else None,
        'component_search_source': 'Database' if parsed_results else 'None',
        'show_get_data_button': not parsed_results,
        'currency': 'USD',  # Changed from INR to USD
        'currency_symbol': '$'  # Added $ symbol
    }

    return render(request, 'componentdetails.html', context)

def handle_uploaded_file(uploaded_file):
    """Optimized file handling"""
    ext = os.path.splitext(uploaded_file.name)[1]
    
    with tempfile.NamedTemporaryFile(delete=False, suffix=ext) as tmp:
        for chunk in uploaded_file.chunks():
            tmp.write(chunk)
        return tmp.name

@performance_monitor
def component_search_view(request):
    result = None
    not_found = False

    if request.method == 'POST':
        form = ComponentSearchForm(request.POST)
        if form.is_valid():
            part_number = form.cleaned_data['manufacturer_part_number']
            currency = 'USD'  # Changed from form.cleaned_data.get('currency') or 'USD'
            country_code = form.cleaned_data.get('country_code') or 'AT'

            # Use cache for search results
            cache_key = get_cache_key('component_search_view', part_number, currency, country_code)
            cached_result = cache.get(cache_key)
            
            if cached_result:
                result = cached_result
            else:
                result = search_component_by_part_number(part_number, currency, country_code)
                
                # Update currency in result
                if result and 'price_breaks' in result:
                    for price_break in result['price_breaks']:
                        if 'currency' in price_break:
                            price_break['currency'] = 'USD'  # Changed from INR to USD
                        if 'price' in price_break:
                            price_break['formatted_price'] = format_price_usd(price_break['price'])
                
                # Cache for 5 minutes
                cache.set(cache_key, result, CACHE_SHORT)
            
            if 'error' in result:
                not_found = True
    else:
        form = ComponentSearchForm()

    return render(request, 'component_search.html', {
        'form': form,
        'result': result,
        'not_found': not_found,
        'currency': 'USD',  # Changed from INR to USD
        'currency_symbol': '$'  # Added $ symbol
    })

logger = logging.getLogger(__name__)

# COMPONENT LIST AND PRICE GRAPH VIEWS
@cache_page(CACHE_SHORT)
def component_list(request):
    """Optimized view to display all components with search functionality"""
    search_query = request.GET.get('search', '')
    page_number = request.GET.get('page', 1)
    
    # Use cache for component list
    cache_key = get_cache_key('component_list', search_query, page_number)
    cached_data = cache.get(cache_key)
    
    if cached_data:
        return render(request, 'component_list.html', cached_data)
    
    # Get unique components with optimized query
    components_query = ComponentCrons.objects.values('component_name').distinct()
    
    if search_query:
        components_query = components_query.filter(component_name__icontains=search_query)
    
    # Build component list efficiently
    component_list = []
    for comp in components_query:
        component_name = comp['component_name']
        
        # Get latest entry and price in optimized queries
        latest_entry = ComponentCrons.objects.filter(
            component_name=component_name
        ).order_by('-fetched_at').first()
        
        latest_price = ComponentPrice.objects.filter(
            part_number=component_name
        ).order_by('-date', 'quantity').first()
        
        component_list.append({
            'name': component_name,
            'source': latest_entry.source if latest_entry else 'Unknown',
            'last_updated': latest_entry.fetched_at if latest_entry else None,
            'latest_price': latest_price.price if latest_price else None,
            'currency': 'USD',  # Changed from latest_price.currency to USD
            'formatted_price': format_price_usd(latest_price.price) if latest_price else None,
            'data_points': ComponentPrice.objects.filter(part_number=component_name).count()
        })
    
    # Paginate results
    paginator = Paginator(component_list, 20)
    page_obj = paginator.get_page(page_number)
    
    context = {
        'components': page_obj,
        'search_query': search_query,
        'total_components': len(component_list),
        'currency': 'USD',  # Changed from INR to USD
        'currency_symbol': '$'  # Added $ symbol
    }
    
    # Cache for 5 minutes
    cache.set(cache_key, context, CACHE_SHORT)
    
    return render(request, 'component_list.html', context)


from functools import lru_cache
from collections import defaultdict
from datetime import date, timedelta
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import numpy as np
import io
import base64
import logging

logger = logging.getLogger(__name__)

@lru_cache(maxsize=100)
def generate_price_graphs(component_name, days=30):
    """Optimized price graph generation with caching"""
    try:
        # Use cache for graph data
        cache_key = get_cache_key('price_graphs', component_name, days)
        cached_data = cache.get(cache_key)
        
        if cached_data:
            return cached_data

        today = date.today()
        start_date = today - timedelta(days=days)
        
        logger.info(f"Generating graphs for {component_name}")
        logger.info(f"Date range: {start_date} to {today} ({days} days)")
        
        # Optimized query
        price_data = ComponentPrice.objects.filter(
            part_number=component_name,
            date__gte=start_date,
            date__lte=today
        ).order_by('date', 'quantity')
        
        logger.info(f"Found {price_data.count()} price records")
        
        if not price_data.exists():
            logger.warning(f"No price data found for {component_name}")
            return None, None, []
        
        # Group data by quantity more efficiently
        quantity_data = defaultdict(list)
        for price in price_data:
            quantity_data[price.quantity].append({
                'date': price.date,
                'price': float(price.price),
                'currency': 'USD'
            })
        
        sorted_quantities = sorted(quantity_data.keys())
        currency = 'USD'
        
        if not sorted_quantities:
            return None, None, []
        
        logger.info(f"Processing {len(sorted_quantities)} different quantities: {sorted_quantities}")
        
        # Modern matplotlib settings with dark theme
        plt.style.use('dark_background')
        plt.rcParams.update({
            'figure.facecolor': '#1a1a1a',
            'axes.facecolor': '#2d2d2d',
            'axes.edgecolor': '#404040',
            'axes.labelcolor': '#e0e0e0',
            'text.color': '#e0e0e0',
            'xtick.color': '#b0b0b0',
            'ytick.color': '#b0b0b0',
            'font.size': 11,
            'axes.titlesize': 16,
            'axes.labelsize': 13,
            'xtick.labelsize': 10,
            'ytick.labelsize': 10,
            'legend.fontsize': 10,
            'grid.color': '#404040',
            'grid.alpha': 0.3
        })
        
        fig, ax = plt.subplots(figsize=(16, 10))
        fig.patch.set_facecolor('#1a1a1a')
        
        # Modern color palette - vibrant but professional
        colors = ['#00D4AA', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
                  '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE',
                  '#85C1E9', '#F8C471', '#82E0AA', '#F1948A', '#85C1E9']
        
        # Simplified data collection - no detailed statistics
        graphs_data = []
        
        for idx, quantity in enumerate(sorted_quantities):
            data = quantity_data[quantity]
            dates = [item['date'] for item in data]
            prices = [item['price'] for item in data]
            
            logger.info(f"Quantity {quantity}: {len(dates)} data points")
            
            color = colors[idx % len(colors)]
            ax.plot(dates, prices, 
                   marker='o', 
                   linewidth=2.5, 
                   markersize=5, 
                   color=color, 
                   label=f'{quantity:,} pcs',
                   markerfacecolor=color, 
                   markeredgewidth=1.5, 
                   markeredgecolor='#1a1a1a',
                   alpha=0.9)
            
            # Only store essential data for summary graph
            if prices:
                graphs_data.append({
                    'quantity': quantity,
                    'min_price': min(prices),
                    'max_price': max(prices),
                    'avg_price': sum(prices) / len(prices)
                })
        
        # Customize chart with modern styling
        title = f'Price Trends for {component_name}\n{start_date.strftime("%b %d, %Y")} to {today.strftime("%b %d, %Y")}'
        ax.set_title(title, fontsize=18, fontweight='bold', pad=25, color='#e0e0e0')
        ax.set_xlabel('Date', fontsize=14, fontweight='500', color='#e0e0e0')
        ax.set_ylabel('Price (USD)', fontsize=14, fontweight='500', color='#e0e0e0')
        ax.grid(True, alpha=0.2, linestyle='-', linewidth=0.5)
        ax.set_facecolor('#2d2d2d')
        
        # Format dates
        actual_dates = list(price_data.values_list('date', flat=True).distinct().order_by('date'))
        if actual_dates:
            ax.set_xlim(min(actual_dates), max(actual_dates))
            
            if days <= 7:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
                ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
            elif days <= 30:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
                ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(actual_dates)//8)))
            elif days <= 90:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
                ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=max(1, len(actual_dates)//10)))
            else:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%y'))
                ax.xaxis.set_major_locator(mdates.MonthLocator(interval=max(1, len(actual_dates)//8)))
            
            plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right', color='#b0b0b0')
        
        ax.margins(x=0.01, y=0.05)
        
        # Modern legend styling
        legend = ax.legend(loc='upper left', 
                          bbox_to_anchor=(0.02, 0.98),
                          frameon=True, 
                          fancybox=True, 
                          shadow=False,
                          ncol=min(3, len(sorted_quantities)),
                          fontsize=10)
        legend.get_frame().set_facecolor('#404040')
        legend.get_frame().set_alpha(0.9)
        legend.get_frame().set_edgecolor('#606060')
        
        # Clean axes styling
        for spine in ax.spines.values():
            spine.set_color('#404040')
            spine.set_linewidth(1)
        
        plt.tight_layout()
        plt.subplots_adjust(top=0.88, bottom=0.12, left=0.08, right=0.95)
        
        # Convert to base64
        buffer = io.BytesIO()
        plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight', 
                    facecolor='#1a1a1a', edgecolor='none', pad_inches=0.3)
        buffer.seek(0)
        image_base64 = base64.b64encode(buffer.getvalue()).decode()
        plt.close()
        
        # Create bigger and cleaner summary graph without detailed statistics
        summary_image_base64 = None
        if len(graphs_data) > 1:
            try:
                # Increased figure size significantly
                summary_fig, summary_ax = plt.subplots(figsize=(18, 12))
                summary_fig.patch.set_facecolor('#1a1a1a')
                
                quantities_list = [data['quantity'] for data in graphs_data]
                avg_prices = [data['avg_price'] for data in graphs_data]
                min_prices = [data['min_price'] for data in graphs_data]
                max_prices = [data['max_price'] for data in graphs_data]
                
                x = np.arange(len(quantities_list))
                width = 0.25
                
                # Modern gradient-like colors for bars
                bars1 = summary_ax.bar(x - width, min_prices, width, label='Min Price', 
                                      color='#00D4AA', alpha=0.8, edgecolor='#1a1a1a', linewidth=1.5)
                bars2 = summary_ax.bar(x, avg_prices, width, label='Avg Price', 
                                      color='#4ECDC4', alpha=0.8, edgecolor='#1a1a1a', linewidth=1.5)
                bars3 = summary_ax.bar(x + width, max_prices, width, label='Max Price', 
                                      color='#FF6B6B', alpha=0.8, edgecolor='#1a1a1a', linewidth=1.5)
                
                summary_ax.set_xlabel('Quantity (pieces)', fontsize=16, fontweight='500', color='#e0e0e0')
                summary_ax.set_ylabel('Price (USD)', fontsize=16, fontweight='500', color='#e0e0e0')
                summary_ax.set_title(f'Price Summary Comparison - {component_name}\n{start_date.strftime("%b %d")} - {today.strftime("%b %d, %Y")}', 
                                    fontsize=20, fontweight='bold', pad=30, color='#e0e0e0')
                summary_ax.set_xticks(x)
                summary_ax.set_xticklabels([f'{q:,}' for q in quantities_list], fontsize=12, color='#b0b0b0')
                
                # Modern legend
                legend = summary_ax.legend(frameon=True, loc='upper left', fontsize=12)
                legend.get_frame().set_facecolor('#404040')
                legend.get_frame().set_alpha(0.9)
                legend.get_frame().set_edgecolor('#606060')
                
                summary_ax.grid(True, alpha=0.2, axis='y', linestyle='-', linewidth=0.5)
                summary_ax.set_facecolor('#2d2d2d')
                
                # Clean axes
                for spine in summary_ax.spines.values():
                    spine.set_color('#404040')
                    spine.set_linewidth(1)
                
                # Simple price labels without detailed formatting
                def add_value_labels(bars, values):
                    for bar, value in zip(bars, values):
                        height = bar.get_height()
                        summary_ax.text(bar.get_x() + bar.get_width()/2., height + max(max_prices) * 0.015,
                                       f'${value:.2f}', ha='center', va='bottom', 
                                       fontsize=11, fontweight='bold', color='#e0e0e0')
                
                add_value_labels(bars1, min_prices)
                add_value_labels(bars2, avg_prices)
                add_value_labels(bars3, max_prices)
                
                plt.tight_layout()
                plt.subplots_adjust(top=0.85, bottom=0.1, left=0.08, right=0.95)
                
                summary_buffer = io.BytesIO()
                plt.savefig(summary_buffer, format='png', dpi=200, bbox_inches='tight',
                           facecolor='#1a1a1a', edgecolor='none', pad_inches=0.3)
                summary_buffer.seek(0)
                summary_image_base64 = base64.b64encode(summary_buffer.getvalue()).decode()
                plt.close()
            except Exception as e:
                logger.error(f"Error creating summary graph: {e}")
                summary_image_base64 = None
        
        result = (image_base64, summary_image_base64, graphs_data)
        
        # Cache for 30 minutes
        cache.set(cache_key, result, CACHE_LONG // 2)
        
        logger.info(f"Successfully generated graphs for {component_name} with {len(graphs_data)} quantities")
        return result
        
    except Exception as e:
        logger.error(f"Error generating graphs for {component_name}: {e}")
        return None, None, []

@performance_monitor
def component_price_graph(request, component_name):
    """Optimized view to display price graph for a specific component"""
    try:
        component = ComponentCrons.objects.filter(component_name=component_name).first()
    except Exception as e:
        logger.error(f"Error fetching component {component_name}: {e}")
        component = None
    
    days = int(request.GET.get('days', 30))
    logger.info(f"Loading component_price_graph for {component_name}, days: {days}")
    
    # Generate graphs
    price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
    
    # Get component details
    latest_entry = ComponentCrons.objects.filter(
        component_name=component_name
    ).order_by('-fetched_at').first()
    
    context = {
        'component_name': component_name,
        'component': latest_entry,
        'price_graph': price_graph,
        'summary_graph': summary_graph,
        'graphs_data': graphs_data,
        'currency': 'USD',
        'currency_symbol': '$',
        'selected_days': days,
        'has_data': price_graph is not None
    }
    
    logger.info(f"Context: has_data={context['has_data']}, selected_days={context['selected_days']}")
    return render(request, 'component_price_graph.html', context)






# @lru_cache(maxsize=100)
# def generate_price_graphs(component_name, days=30):
#     """Optimized price graph generation with caching"""
#     try:
#         # Use cache for graph data
#         cache_key = get_cache_key('price_graphs', component_name, days)
#         cached_data = cache.get(cache_key)
        
#         if cached_data:
#             return cached_data

#         today = date.today()
#         start_date = today - timedelta(days=days)
        
#         logger.info(f"Generating graphs for {component_name}")
#         logger.info(f"Date range: {start_date} to {today} ({days} days)")
        
#         # Optimized query
#         price_data = ComponentPrice.objects.filter(
#             part_number=component_name,
#             date__gte=start_date,
#             date__lte=today
#         ).order_by('date', 'quantity')
        
#         logger.info(f"Found {price_data.count()} price records")
        
#         if not price_data.exists():
#             logger.warning(f"No price data found for {component_name}")
#             return None, None, []
        
#         # Group data by quantity more efficiently
#         quantity_data = defaultdict(list)
#         for price in price_data:
#             quantity_data[price.quantity].append({
#                 'date': price.date,
#                 'price': float(price.price),
#                 'currency': 'USD'  # Changed from price.currency to USD
#             })
        
#         sorted_quantities = sorted(quantity_data.keys())
#         currency = 'USD'  # Changed from price_data.first().currency to USD
        
#         if not sorted_quantities:
#             return None, None, []
        
#         logger.info(f"Processing {len(sorted_quantities)} different quantities: {sorted_quantities}")
        
#         # Optimize matplotlib settings
#         plt.style.use('default')
#         plt.rcParams.update({
#             'figure.facecolor': 'white',
#             'axes.facecolor': 'white',
#             'font.size': 12,
#             'axes.titlesize': 16,
#             'axes.labelsize': 14,
#             'xtick.labelsize': 12,
#             'ytick.labelsize': 12,
#             'legend.fontsize': 11
#         })
        
#         fig, ax = plt.subplots(figsize=(16, 10))
        
#         colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6', 
#                   '#06B6D4', '#84CC16', '#F97316', '#EC4899', '#6366F1',
#                   '#14B8A6', '#F472B6', '#A855F7', '#22D3EE', '#FDE047']
        
#         graphs_data = []
        
#         for idx, quantity in enumerate(sorted_quantities):
#             data = quantity_data[quantity]
#             dates = [item['date'] for item in data]
#             prices = [item['price'] for item in data]
            
#             logger.info(f"Quantity {quantity}: {len(dates)} data points")
            
#             color = colors[idx % len(colors)]
#             ax.plot(dates, prices, 
#                    marker='o', 
#                    linewidth=3, 
#                    markersize=6, 
#                    color=color, 
#                    label=f'{quantity:,} pcs',
#                    markerfacecolor='white', 
#                    markeredgewidth=2, 
#                    markeredgecolor=color,
#                    alpha=0.8)
            
#             if prices:
#                 graphs_data.append({
#                     'quantity': quantity,
#                     'min_price': min(prices),
#                     'max_price': max(prices),
#                     'avg_price': sum(prices) / len(prices),
#                     'data_points': len(prices),
#                     'currency': currency,
#                     'formatted_min_price': format_price_usd(min(prices)),
#                     'formatted_max_price': format_price_usd(max(prices)),
#                     'formatted_avg_price': format_price_usd(sum(prices) / len(prices)),
#                     'date_range': f"{min(dates).strftime('%m/%d')} - {max(dates).strftime('%m/%d')}"
#                 })
        
#         # Customize chart
#         title = f'Price Trends for {component_name}\n({start_date.strftime("%b %d, %Y")} to {today.strftime("%b %d, %Y")} - {days} days)'
#         ax.set_title(title, fontsize=18, fontweight='bold', pad=30)
#         ax.set_xlabel('Date', fontsize=14, fontweight='500')
#         ax.set_ylabel('Price (USD)', fontsize=14, fontweight='500')  # Changed from ({currency}) to (USD)
#         ax.grid(True, alpha=0.3, linestyle='--')
#         ax.set_facecolor('#FAFAFA')
        
#         # Format dates
#         actual_dates = list(price_data.values_list('date', flat=True).distinct().order_by('date'))
#         if actual_dates:
#             ax.set_xlim(min(actual_dates), max(actual_dates))
            
#             if days <= 7:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=1))
#             elif days <= 30:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.DayLocator(interval=max(1, len(actual_dates)//8)))
#             elif days <= 90:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
#                 ax.xaxis.set_major_locator(mdates.WeekdayLocator(interval=max(1, len(actual_dates)//10)))
#             else:
#                 ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d/%y'))
#                 ax.xaxis.set_major_locator(mdates.MonthLocator(interval=max(1, len(actual_dates)//8)))
            
#             plt.setp(ax.xaxis.get_majorticklabels(), rotation=45, ha='right')
        
#         ax.margins(x=0.01, y=0.05)
        
#         # Add legend
#         legend = ax.legend(loc='upper left', 
#                           bbox_to_anchor=(0.02, 0.98),
#                           frameon=True, 
#                           fancybox=True, 
#                           shadow=True,
#                           ncol=min(3, len(sorted_quantities)),
#                           fontsize=11)
#         legend.get_frame().set_facecolor('white')
#         legend.get_frame().set_alpha(0.9)
        
#         # Style axes
#         ax.spines['top'].set_visible(False)
#         ax.spines['right'].set_visible(False)
#         ax.spines['left'].set_color('#E5E7EB')
#         ax.spines['bottom'].set_color('#E5E7EB')
        
#         plt.tight_layout()
#         plt.subplots_adjust(top=0.85, bottom=0.15, left=0.08, right=0.95)
        
#         # Convert to base64
#         buffer = io.BytesIO()
#         plt.savefig(buffer, format='png', dpi=200, bbox_inches='tight', 
#                     facecolor='white', edgecolor='none', pad_inches=0.3)
#         buffer.seek(0)
#         image_base64 = base64.b64encode(buffer.getvalue()).decode()
#         plt.close()
        
#         # Create summary graph
#         summary_image_base64 = None
#         if len(graphs_data) > 1:
#             try:
#                 summary_fig, summary_ax = plt.subplots(figsize=(14, 8))
#                 summary_fig.patch.set_facecolor('white')
                
#                 quantities_list = [data['quantity'] for data in graphs_data]
#                 avg_prices = [data['avg_price'] for data in graphs_data]
#                 min_prices = [data['min_price'] for data in graphs_data]
#                 max_prices = [data['max_price'] for data in graphs_data]
                
#                 x = np.arange(len(quantities_list))
#                 width = 0.25
                
#                 bars1 = summary_ax.bar(x - width, min_prices, width, label='Min Price', 
#                                       color='#10B981', alpha=0.8, edgecolor='white', linewidth=2)
#                 bars2 = summary_ax.bar(x, avg_prices, width, label='Avg Price', 
#                                       color='#3B82F6', alpha=0.8, edgecolor='white', linewidth=2)
#                 bars3 = summary_ax.bar(x + width, max_prices, width, label='Max Price', 
#                                       color='#EF4444', alpha=0.8, edgecolor='white', linewidth=2)
                
#                 summary_ax.set_xlabel('Quantity (pieces)', fontsize=12, fontweight='500')
#                 summary_ax.set_ylabel('Price (USD)', fontsize=12, fontweight='500')  # Changed from ({currency}) to (USD)
#                 summary_ax.set_title(f'Price Summary for {component_name}\n({start_date.strftime("%b %d")} - {today.strftime("%b %d, %Y")})', 
#                                     fontsize=16, fontweight='bold', pad=20)
#                 summary_ax.set_xticks(x)
#                 summary_ax.set_xticklabels([f'{q:,}' for q in quantities_list])
#                 summary_ax.legend(frameon=False, loc='upper left')
#                 summary_ax.grid(True, alpha=0.3, axis='y', linestyle='--')
#                 summary_ax.set_facecolor('#FAFAFA')
                
#                 summary_ax.spines['top'].set_visible(False)
#                 summary_ax.spines['right'].set_visible(False)
#                 summary_ax.spines['left'].set_color('#E5E7EB')
#                 summary_ax.spines['bottom'].set_color('#E5E7EB')
                
#                 # Add value labels with $ symbol
#                 def add_value_labels(bars, values):
#                     for bar, value in zip(bars, values):
#                         height = bar.get_height()
#                         summary_ax.text(bar.get_x() + bar.get_width()/2., height + max(max_prices) * 0.02,
#                                        format_price_usd(value), ha='center', va='bottom', fontsize=10, fontweight='bold')
                
#                 add_value_labels(bars1, min_prices)
#                 add_value_labels(bars2, avg_prices)
#                 add_value_labels(bars3, max_prices)
                
#                 plt.tight_layout()
                
#                 summary_buffer = io.BytesIO()
#                 plt.savefig(summary_buffer, format='png', dpi=200, bbox_inches='tight',
#                            facecolor='white', edgecolor='none', pad_inches=0.2)
#                 summary_buffer.seek(0)
#                 summary_image_base64 = base64.b64encode(summary_buffer.getvalue()).decode()
#                 plt.close()
#             except Exception as e:
#                 logger.error(f"Error creating summary graph: {e}")
#                 summary_image_base64 = None
        
#         result = (image_base64, summary_image_base64, graphs_data)
        
#         # Cache for 30 minutes
#         cache.set(cache_key, result, CACHE_LONG // 2)
        
#         logger.info(f"Successfully generated graphs for {component_name} with {len(graphs_data)} quantities")
#         return result
        
#     except Exception as e:
#         logger.error(f"Error generating graphs for {component_name}: {e}")
#         return None, None, []

# @performance_monitor
# def component_price_graph(request, component_name):
#     """Optimized view to display price graph for a specific component"""
#     try:
#         component = ComponentCrons.objects.filter(component_name=component_name).first()
#     except Exception as e:
#         logger.error(f"Error fetching component {component_name}: {e}")
#         component = None
    
#     days = int(request.GET.get('days', 30))
#     logger.info(f"Loading component_price_graph for {component_name}, days: {days}")
    
#     # Generate graphs
#     price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
    
#     # Get component details
#     latest_entry = ComponentCrons.objects.filter(
#         component_name=component_name
#     ).order_by('-fetched_at').first()
    
#     context = {
#         'component_name': component_name,
#         'component': latest_entry,
#         'price_graph': price_graph,
#         'summary_graph': summary_graph,
#         'graphs_data': graphs_data,
#         'currency': 'USD',  # Changed from latest_price.currency to USD
#         'currency_symbol': '$',  # Added $ symbol
#         'selected_days': days,
#         'has_data': price_graph is not None
#     }
    
#     logger.info(f"Context: has_data={context['has_data']}, selected_days={context['selected_days']}")
#     return render(request, 'component_price_graph.html', context)

@performance_monitor
def component_price_api(request, component_name):
    """Optimized API endpoint to get price data for AJAX requests"""
    days = int(request.GET.get('days', 30))
    logger.info(f"API call for {component_name}, days: {days}")
    
    try:
        price_graph, summary_graph, graphs_data = generate_price_graphs(component_name, days)
        
        response_data = {
            'price_graph': price_graph,
            'summary_graph': summary_graph,
            'graphs_data': graphs_data,
            'has_data': price_graph is not None,
            'currency': 'USD',  # Changed from graphs_data[0]['currency'] to USD
            'currency_symbol': '$',  # Added $ symbol
            'days': days
        }
        
        logger.info(f"API response: has_data={response_data['has_data']}, days={days}")
        return JsonResponse(response_data)
        
    except Exception as e:
        logger.error(f"API error for {component_name}: {e}")
        return JsonResponse({
            'error': str(e),
            'has_data': False,
            'price_graph': None,
            'summary_graph': None,
            'graphs_data': [],
            'currency': 'USD',  # Changed from INR to USD
            'currency_symbol': '$',  # Added $ symbol
            'days': days
        }, status=500)